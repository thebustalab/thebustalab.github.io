hlines = FALSE,
hlines_data = NULL,
tick_spacing = 5,
ticks_text_size = 30,
order = NULL,
color_pal = NULL
) {
if (wrap == FALSE) {
if (roi == FALSE) {
print("Please specify either wrap OR roi")
stop()
}
}
if (wrap == TRUE) {
if (roi == TRUE) {
print("Please specify either wrap OR roi")
stop()
}
}
# Read alignment, create basic plottable
AA_phydat <- as.data.frame(as.character(phangorn::read.aa(file = infile, format = "fasta")))
AA_phydat <- as.data.frame(t(AA_phydat))
colnames(AA_phydat) <- as.character(seq(1,dim(AA_phydat)[2],1))
AA_alignment_df <-  cbind(
data.frame(protein = paste(
seqlist[,which(colnames(seqlist) == alignment_labels)][match(rownames(as.matrix(AA_phydat)), seqlist$accession)]
)),
data.frame(funct = seqlist[,colnames(seqlist)=="Function"][match(rownames(as.matrix(AA_phydat)), seqlist[,1])]),
data.frame(y = rep(0,dim(AA_phydat)[1])),
AA_phydat
)
AA_alignment_df_plottable <- tidyr::gather(AA_alignment_df, position, residue, 4:dim(AA_alignment_df)[2])
AA_alignment_df_plottable$position <- as.numeric(as.character(AA_alignment_df_plottable$position))
AA_alignment_df_plottable <- AA_alignment_df_plottable[order(AA_alignment_df_plottable$protein, AA_alignment_df_plottable$position),]
head(AA_alignment_df_plottable)
# Make wrapping list
if (wrap == TRUE) {
wrap_break_points <- list()
for (i in 1:(dim(AA_phydat)[2]%/%wrap_length)) {
wrap_break_points <- c(wrap_break_points, 1+(wrap_length*(i)))
}
head(wrap_break_points)
}
if (roi == TRUE) {
wrap_break_points <- dim(AA_phydat)[2]
head(wrap_break_points)
wrap_length = dim(AA_phydat)[2]
}
# ROI
if (roi == TRUE) {
#Define the ROI and Modify the alignment plottable
roi_ranges <- rep("NA",dim(AA_phydat)[2])
range_names <- roi_data[,1]
for (i in 1:dim(roi_data)[1]) {
roi_ranges[as.numeric(as.character(roi_data[i,2])):as.numeric(as.character(roi_data[i,3]))] <- as.character(roi_data[i,1])
}
AA_alignment_df_plottable$roi_ranges <- rep(roi_ranges, length(unique(AA_alignment_df_plottable$protein)))
AA_alignment_df_plottable <- subset(AA_alignment_df_plottable, roi_ranges %in% as.character(range_names))
}
# ORDER the sequences to optionally match the alignment with a tree or something
if (!is.null(order)) {
AA_alignment_df_plottable$protein <- factor(AA_alignment_df_plottable$protein, levels=order)
}
# Initiate the plot(s)
plot_list <- list()
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <-   ggplot2::ggplot(data = AA_alignment_df_plottable[AA_alignment_df_plottable$position %in%
as.numeric(as.character(unlist(wrap_break_points)[i]-wrap_length)):
as.numeric(as.character(unlist(wrap_break_points)[i])),],
aes(x = position, y = y)
)
}
# HIGHLIGHTS
if (highlights == TRUE) {
if (roi == TRUE) {
highlights_data <- cbind(highlights_data, data.frame(roi_ranges=roi_ranges[highlights_data$xint]))
}
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <- plot_list[[i]] +  geom_vline(
data=highlights_data[highlights_data$xint %in%
as.numeric(as.character(unlist(wrap_break_points)[i]-wrap_length)):
as.numeric(as.character(unlist(wrap_break_points)[i])),],
aes(xintercept=xint, color=as.character(xint)),
size=3
)
}
}
# CONSENSUS
if (consensus == TRUE) {
# Calculate consensus scores
#Calculate max possible score:
AA_phydat_char_distrib <- t(as.data.frame(lapply(apply(AA_phydat,2,table), sd)))
AA_phydat_char_distrib[is.na(AA_phydat_char_distrib)] <- 0
max_consensus_score <- ceiling(max(AA_phydat_char_distrib))
# Calculate consensus scores:
AA_phydat_char_distrib <- t(as.data.frame(lapply(apply(AA_phydat,2,table), sd)))
AA_phydat_char_distrib[is.na(AA_phydat_char_distrib)] <- max_consensus_score
colnames(AA_phydat_char_distrib) <- "consensus_score"
AA_phydat_char_distrib <- normalize(AA_phydat_char_distrib)*consensus_height
# Bind consensus score
consensus_protein <- data.frame(
protein = "consensus",
funct="none",
y=AA_phydat_char_distrib[,1],
position=seq(1,dim(AA_phydat)[2]),
residue="+"
)
head(consensus_protein)
# Truncate the consensus_protein to fit roi
if (roi == TRUE) {
consensus_protein <- cbind(
consensus_protein,
data.frame(roi_ranges=  rep(    roi_ranges,
length(unique(consensus_protein$protein))
)
)
)
consensus_protein <- subset(consensus_protein, roi_ranges %in% range_names)
}
# Add consensus_protein to the plot(s) in plot_list
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <-  plot_list[[i]] + layer(  data=consensus_protein[consensus_protein$position %in%
as.numeric(as.character(unlist(wrap_break_points)[i]-wrap_length)):
as.numeric(as.character(unlist(wrap_break_points)[i])),],
aes(x=position, y=y), geom="line", stat="identity", position="identity"
)
}
}
# FUNCTIONAL ASSOCIATION
if (funct_assoc == TRUE) {
for (j in 1:length(funct_assoc_data)) {
# Subset alignment matrices for the two variables
alignment_matrix <- toupper(t(as.data.frame(as.character(phangorn::read.aa(file = infile, format = "fasta")))))
spec1 <- list()
spec1[[1]] <- seqlist[,colnames(seqlist) == funct_assoc_data[j]] == as.character(gsub("~.*$", "", funct_assoc_data[j]))
alignment_matrix_dim1 <- alignment_matrix[Reduce("&", spec1),]
dim(alignment_matrix_dim1)
spec2 <- list()
spec2[[1]] <- seqlist[,colnames(seqlist)==funct_assoc_data[j]] == as.character(gsub(".*~", "", funct_assoc_data[j]))
alignment_matrix_dim2 <- alignment_matrix[Reduce("&", spec2),]
dim(alignment_matrix_dim2)
#Set up fixed substitution table
fixed_sub_table <- data.frame(funct = c(as.character(gsub("~.*$", "", funct_assoc_data[j])), as.character(gsub(".*~", "", funct_assoc_data[j]))), code=c(1,2))
#Get frequency stats from the first alignment subset
alignment_matrix_dim1_char_distrib <- lapply(apply(alignment_matrix_dim1,2,table), sort, decreasing=TRUE)
alignment_matrix_dim2_char_distrib <- lapply(apply(alignment_matrix_dim2,2,table), sort, decreasing=TRUE)
#Set up empty assoc matrix
association_list <- list()
for (i in 1:dim(alignment_matrix)[2]){
# Set up dim1 residue substitution table
base_sub_table_dim1 <- data.frame(letter=LETTERS, number=rep(2,26))
base_sub_table_dim1 <- rbind(base_sub_table_dim1, data.frame(letter="-", number=2))
sub_position_dim1 <- data.frame(consensus=names(alignment_matrix_dim1_char_distrib[[i]][1]), number=1)
positional_sub_table_dim1 <- base_sub_table_dim1
positional_sub_table_dim1$number <- sub_position_dim1$number[match(positional_sub_table_dim1$letter, sub_position_dim1$consensus)]
positional_sub_table_dim1[is.na(positional_sub_table_dim1$number),]$number <- 2
positional_sub_table_dim1
# Substitute in the first alignment subset
positional_data_frame_dim1 <- data.frame(
enzyme=names(alignment_matrix_dim1[,i]),
funct=as.character(gsub("~.*$", "", funct_assoc_data[j])),
x_num=as.character(gsub("~.*$", "", funct_assoc_data[j])),
position=i,
residue=alignment_matrix_dim1[,i],
y_num=alignment_matrix_dim1[,i]
)
positional_data_frame_dim1$x_num <- fixed_sub_table$code[match(positional_data_frame_dim1$x_num, fixed_sub_table$funct)]
positional_data_frame_dim1$y_num <- positional_sub_table_dim1$number[match(positional_data_frame_dim1$y_num, positional_sub_table_dim1$letter)]
positional_data_frame_dim1
# Set up dim2 residue substitution table
base_sub_table_dim2 <- data.frame(letter=LETTERS, number=rep(1,26))
base_sub_table_dim2 <- rbind(base_sub_table_dim2, data.frame(letter="-", number=1))
sub_position_dim2 <- data.frame(consensus=names(alignment_matrix_dim2_char_distrib[[i]][1]), number=2)
if (as.character(sub_position_dim2$consensus) == as.character(sub_position_dim1$consensus)) {sub_position_dim2$number <- 1}
positional_sub_table_dim2 <- base_sub_table_dim2
positional_sub_table_dim2$number <- sub_position_dim2$number[match(positional_sub_table_dim2$letter, sub_position_dim2$consensus)]
positional_sub_table_dim2[is.na(positional_sub_table_dim2$number),]$number <- 1
positional_sub_table_dim2
#Substitute in the second alignment subset
positional_data_frame_dim2 <- data.frame(
enzyme=names(alignment_matrix_dim2[,i]),
funct=as.character(gsub(".*~", "", funct_assoc_data[j])),
x_num=as.character(gsub(".*~", "", funct_assoc_data[j])),
position=i,
residue=alignment_matrix_dim2[,i],
y_num=alignment_matrix_dim2[,i]
)
positional_data_frame_dim2$x_num <- fixed_sub_table$code[match(positional_data_frame_dim2$x_num, fixed_sub_table$funct)]
positional_data_frame_dim2$y_num <- positional_sub_table_dim2$number[match(positional_data_frame_dim2$y_num, positional_sub_table_dim2$letter)]
#Add the positional_data_frame to the list
association_list[[i]] <- rbind(positional_data_frame_dim1, positional_data_frame_dim2)
}
# USE THIS LINE TO MANUALLY INSPECT SITE ASSOCIATAIONS
# association_list[[273]]
cor_list <- list()
for (i in 1:length(association_list)) {
cor_list[i] <- cor(cbind(association_list[[i]]$x_num,association_list[[i]]$y_num))[1,2]
}
cor_list[is.na(cor_list)] <- 0
cor_list[cor_list < 0] <- 0
correlation_protein <-  data.frame(
protein = as.character(funct_assoc_data[j]),
funct = "NA",
y = t(as.data.frame(cor_list))*funct_assoc_height,
position = seq(1,length(cor_list),1),
residue = "NA"
)
head(correlation_protein)
# Truncate the correlation_protein plottable so it only contains things in the roi
if (roi == TRUE) {
correlation_protein <- cbind(
correlation_protein,
data.frame(roi_ranges=rep(
roi_ranges,
length(unique(correlation_protein$protein)))
)
)
correlation_protein <- subset(correlation_protein, roi_ranges %in% range_names)
}
# Assign correlation protein to global environment
assign("correlation_protein", correlation_protein, envir = .GlobalEnv)
# Add the correlation_protein to the plot(s) in plot_list
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <-  plot_list[[i]] + layer(data=correlation_protein[correlation_protein$position %in%
as.numeric(as.character(unlist(wrap_break_points)[i]-wrap_length)):
as.numeric(as.character(unlist(wrap_break_points)[i])),],
aes(x=position, y=y), geom="line", stat="identity", position="identity"
)
}
}
}
# HLINES
if (hlines == TRUE) {
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <- plot_list[[i]] +  geom_hline(
data = hlines_data,
aes(yintercept = yint),
size = 1,
linetype = 2
)
}
}
# Build the rest of the alignment
#Specify facets based on presence/absence of ROIs
if (roi == TRUE) {
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <- plot_list[[i]] + facet_grid(protein~roi_ranges, scales="free", space="free", switch="y")
}
}
if (wrap == TRUE) {
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <- plot_list[[i]] + facet_grid(protein~., scales="free", space="free", switch="y")
}
}
# Make rest of plot
for (i in 1:length(wrap_break_points)) {
plot_list[[i]] <- plot_list[[i]] + theme_classic()
plot_list[[i]] <- plot_list[[i]] +  scale_x_continuous(
expand = c(0.005,0.005),
name = "",
# breaks = as.numeric(generateTicks(seq(0,5000,tick_spacing))$all_breaks),
# labels = as.character(generateTicks(seq(0,5000,tick_spacing))$all_labels)
)
plot_list[[i]] <- plot_list[[i]] + scale_y_continuous(name = "")
plot_list[[i]] <- plot_list[[i]] + scale_color_manual(values = color_pal)
plot_list[[i]] <- plot_list[[i]] + theme(
panel.spacing.y = unit(0.01, "lines"),
panel.spacing.x = unit(0.2, "cm"),
panel.border = element_blank(),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
axis.text.y = element_blank(),
strip.text.y = element_text(angle = 180),
text = element_text(size = ticks_text_size),
legend.position = "none",
axis.title = element_text(color = "#737373", face = "bold", size = 40),
axis.ticks.length = unit(0.2, "cm"),
axis.ticks = element_line(color = "#737373", size = 1, lineend = 6),
axis.text = element_text(color = "#737373", face = "bold", size = ticks_text_size),
axis.line = element_line(color = "#737373", size = 1),
strip.text = element_text(hjust = 1, size = ticks_text_size),
strip.background = element_blank(),
strip.placement = "outside"
)
}
# Return the Alignment
if (wrap == TRUE) { ## IF USING WRAP, RETURNS A LIST THAT MUST BE PLOTTED USING do.call(gridExtra::grid.arrange,c(alignment, ncol=1))
plots <- list()
for (i in 1:length(wrap_break_points)) {
plots[[i]] <- ggplot2::ggplot_gtable(
ggplot2::ggplot_build(plot_list[[i]] + layer(
data = AA_alignment_df_plottable[AA_alignment_df_plottable$position %in%
as.numeric(as.character(unlist(wrap_break_points)[i]-wrap_length)):
as.numeric(as.character(unlist(wrap_break_points)[i])),],
geom = "text",
mapping = aes(label = residue),
stat = "identity",
position = "identity")
)
)
}
return(plots)
}
if (roi == TRUE) { ## IF USING ROI, RETURNS A GGPLOT THAT CAN BE PLOTTED USING NORMAL GGPLOT PLOTTING TECHNIQUES
plot_list[[i]] <- plot_list[[i]] + layer(
data = AA_alignment_df_plottable[AA_alignment_df_plottable$position %in%
as.numeric(as.character(unlist(wrap_break_points)[i]-wrap_length)):
as.numeric(as.character(unlist(wrap_break_points)[i])),],
geom = "text",
mapping = aes(label = residue),
stat = "identity",
position = "identity")
return(plot_list[[1]])
}
}
#### generateTicks
#' Create major and minor axes ticks and labels
#'
#' @param major_ticks Values at which major ticks should be generated
#' @param minor_freq Number of minor ticks between each major tick
#' @examples
#' @export
#' generateTicks
generateTicks <-    function(major_ticks, minor_freq = 4, major_tick_size, minor_tick_size) {
major_labels <- vector()
for (tick in 1:(length(major_ticks)-1)) {
major_labels <- c(major_labels, major_ticks[tick])
major_labels <- c(major_labels, rep("", (minor_freq)))
}
all_ticks <- vector()
for (tick in 1:(length(major_ticks)-1)) {
all_ticks <- c(all_ticks, major_ticks[tick])
minor_tick_values <- vector()
for (minor_tick in 1:minor_freq) {
minor_tick_values <- c(minor_tick_values, major_ticks[tick] + minor_tick*(((major_ticks[tick+1] - major_ticks[tick])/(minor_freq+1))))
}
all_ticks <- c(all_ticks, minor_tick_values)
}
major_labels <- c(major_labels, major_ticks[length(major_ticks)])
all_ticks <- c(all_ticks, major_ticks[length(major_ticks)])
return <- data.frame(all_ticks = as.numeric(all_ticks), major_labels = as.character(major_labels))
return$tick_size <- minor_tick_size
return$tick_size[return$major_labels != ""] <- major_tick_size
return(return)
}
##### Phylogenetic statistical testing
#### phylogeneticSignal
#' Convert mass spectral datafiles (CDF) into a csv file
#'
#' @param trait A vector of the variable, named according to which tree tip it comes from
#' @param tree A phylogenetic tree with tips that exactly match the names of trait
#' @param replicates Number of random replications to run
#' @param cost Optional. A specialized transition matrix
#' @examples
#' @export
#' phylogeneticSignal
phylogeneticSignal <- function( trait, tree, replicates = 999, cost = NULL ) {
### For discrete traits
## Get the states in which the trait may exist (levels)
levels <- attributes(factor(trait))$levels
## Chech that the variable is indeed categorical
if (length(levels) == length(trait)) {
warn("Are you sure this variable is categorical?")
}
## Make the transition matrix
if (is.null(cost)) {
cost1 <- 1-diag(length(levels))
} else {
if (length(levels) != dim(cost)[1])
stop("Dimensions of the character state transition matrix do not agree with the number of levels")
cost1 <- t(cost)
}
dimnames(cost1) <- list(levels, levels)
## Make the trait numeric
trait_as_numeric <- as.numeric(as.factor(trait))
names(trait_as_numeric) <- names(trait)
## Make the phyDat object and get the parsimony score for the tree with the associated observations
# obs <- t(data.frame(trait))
obs <- phyDat( trait, type = "USER", levels = attributes(factor(trait))$levels )
OBS <- parsimony( tree, obs, method = "sankoff", cost = cost1 )
## Make "replicates" number of random tree-trait associations and check their parsimony score
null_model <- matrix(NA, replicates, 1)
for (i in 1:replicates){
## Randomize the traits and get the parsimony score for the random traits on that tree
null <- sample(as.numeric(trait_as_numeric))
attributes(null)$names <- attributes(trait_as_numeric)$names
# null <- t(data.frame(null))
null <- phyDat( null,type = "USER",levels = attributes(factor(null))$levels )
null_model[i,] <- parsimony( tree, null, method = "sankoff", cost = cost1 )
}
## Assess observed parsimony score in the context of the random ones
p_value <- sum(OBS >= null_model)/(replicates + 1)
p_value
## Summarize output and report it
output <- data.frame(
number_of_levels = length(attributes(factor(trait))$levels),
evolutionary_transitions_observed = OBS,
median_evolutionary_transitions_in_randomization = median(null_model),
minimum_evolutionary_transitions_in_randomization = min(null_model),
evolutionary_transitions_in_randomization = max(null_model),
p_value = p_value
)
return(output)
}
teach_phylochem_fig_dir <- "/Users/lucasbusta/Documents/Science/Teaching/Medicinal Plant Chemistry/2019/figures/Wax_bloom_group/"
wax_species <- unique(data[data$Group == 1,]$Genus_species)
wax_species[wax_species == "Graptopetalum_paraguayense"] <- "Sedum_album"
tphylo$Trees$Wax_bloom_group <- buildTree(
scaffold_type = c("newick"),
scaffold_in_path = "/Users/lucasbusta/Documents/Science/_Lab_Notebook/Phylochemistry/_local_big_data/taxa/angiosperms.newick",
members = wax_species
)
annot <- cbind(data$Genus_species, data)
annot
tphylo_tree <- ggtree(tphylo$Trees$Wax_bloom_group) %<+% annot +
# geom_tiplab(aes(label=paste('italic(', Genus, ')~italic(', Species, ')', sep = "")), parse = TRUE, offset = 30) +
geom_tiplab(offset = 30, align = TRUE, size = 8) +
geom_tippoint(size = 3, alpha = 1, shape = 21, color = "black", fill = "black") +
# scale_color_manual(values = grain_wax_paper_color_scheme, na.value = "black") +
# scale_fill_manual(values = grain_wax_paper_color_scheme) +
# theme(text = element_text(face = "italic")) +
ggplot2::xlim(c(0,200)) +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "transparent", colour = NA),
plot.background = element_rect(fill = "transparent", colour = NA)
)
tphylo_tree
library(ggtree)
tphylo_tree <- ggtree(tphylo$Trees$Wax_bloom_group) %<+% annot +
# geom_tiplab(aes(label=paste('italic(', Genus, ')~italic(', Species, ')', sep = "")), parse = TRUE, offset = 30) +
geom_tiplab(offset = 30, align = TRUE, size = 8) +
geom_tippoint(size = 3, alpha = 1, shape = 21, color = "black", fill = "black") +
# scale_color_manual(values = grain_wax_paper_color_scheme, na.value = "black") +
# scale_fill_manual(values = grain_wax_paper_color_scheme) +
# theme(text = element_text(face = "italic")) +
ggplot2::xlim(c(0,200)) +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "transparent", colour = NA),
plot.background = element_rect(fill = "transparent", colour = NA)
)
tphylo_tree
tphylo$Trees$Wax_bloom_group
library(ape)
library(phytools)
drop.tip(tphylo$Trees$Wax_bloom_group, tip = c("Crassula_deceptor", "Crassula_marneriana")
)
tphylo$Trees$Wax_bloom_group
tphylo$Trees$Wax_bloom_group$tip.label
tphylo$Trees$Wax_bloom_group$tip.label == "Sedum_album"
tphylo$Trees$Wax_bloom_group$tip.label[tphylo$Trees$Wax_bloom_group$tip.label == "Sedum_album"] <- "Graptopetalum_paraguayense"
tphylo_tree <- ggtree(tphylo$Trees$Wax_bloom_group) %<+% annot +
# geom_tiplab(aes(label=paste('italic(', Genus, ')~italic(', Species, ')', sep = "")), parse = TRUE, offset = 30) +
geom_tiplab(offset = 30, align = TRUE, size = 8) +
geom_tippoint(size = 3, alpha = 1, shape = 21, color = "black", fill = "black") +
# scale_color_manual(values = grain_wax_paper_color_scheme, na.value = "black") +
# scale_fill_manual(values = grain_wax_paper_color_scheme) +
# theme(text = element_text(face = "italic")) +
ggplot2::xlim(c(0,200)) +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "transparent", colour = NA),
plot.background = element_rect(fill = "transparent", colour = NA)
)
tphylo_tree
tphylo$Trees$Wax_bloom_group$tip.label[tphylo$Trees$Wax_bloom_group$tip.label == "Sedum_album"] <- "Graptopetalum_paraguayense"
tphylo_tree <- ggtree(tphylo$Trees$Wax_bloom_group) %<+% annot +
# geom_tiplab(aes(label=paste('italic(', Genus, ')~italic(', Species, ')', sep = "")), parse = TRUE, offset = 30) +
geom_tiplab(offset = 30, align = TRUE, size = 8) +
geom_tippoint(size = 3, alpha = 1, shape = 21, color = "black", fill = "black") +
# scale_color_manual(values = grain_wax_paper_color_scheme, na.value = "black") +
# scale_fill_manual(values = grain_wax_paper_color_scheme) +
# theme(text = element_text(face = "italic")) +
ggplot2::xlim(c(0,200)) +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "transparent", colour = NA),
plot.background = element_rect(fill = "transparent", colour = NA)
)
tphylo_tree
teach_phylochem_fig_dir <- "/Users/lucasbusta/Documents/Science/Teaching/Medicinal Plant Chemistry/2019/figures/Wax_bloom_group/"
wax_species <- unique(data[data$Group == 1,]$Genus_species)
wax_species[wax_species == "Graptopetalum_paraguayense"] <- "Sedum_album"
tphylo$Trees$Wax_bloom_group <- buildTree(
scaffold_type = c("newick"),
scaffold_in_path = "/Users/lucasbusta/Documents/Science/_Lab_Notebook/Phylochemistry/_local_big_data/taxa/angiosperms.newick",
members = wax_species
)
annot <- cbind(data$Genus_species, data)
tphylo$Trees$Wax_bloom_group <- drop.tip(tphylo$Trees$Wax_bloom_group, tip = c("Crassula_deceptor", "Crassula_marneriana"))
tphylo$Trees$Wax_bloom_group$tip.label[tphylo$Trees$Wax_bloom_group$tip.label == "Sedum_album"] <- "Graptopetalum_paraguayense"
tphylo_tree <- ggtree(tphylo$Trees$Wax_bloom_group) %<+% annot +
# geom_tiplab(aes(label=paste('italic(', Genus, ')~italic(', Species, ')', sep = "")), parse = TRUE, offset = 30) +
geom_tiplab(offset = 30, align = TRUE, size = 8) +
geom_tippoint(size = 3, alpha = 1, shape = 21, color = "black", fill = "black") +
# scale_color_manual(values = grain_wax_paper_color_scheme, na.value = "black") +
# scale_fill_manual(values = grain_wax_paper_color_scheme) +
# theme(text = element_text(face = "italic")) +
ggplot2::xlim(c(0,200)) +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "transparent", colour = NA),
plot.background = element_rect(fill = "transparent", colour = NA)
)
tphylo_tree
ggplot2::ggsave(file = paste(teach_phylochem_fig_dir, "Wax_bloom_group_tree.pdf", sep = ""), plot = tphylo_tree, device = "pdf", units = "in", width = 8, height = 10, dpi = 300, limitsize = FALSE, bg = "transparent")
ggplot2::ggsave(file = paste(teach_phylochem_fig_dir, "Wax_bloom_group_tree.png", sep = ""), plot = tphylo_tree, device = "png", units = "in", width = 8, height = 10, dpi = 300, limitsize = FALSE, bg = "transparent")
