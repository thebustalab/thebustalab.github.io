}
}
if( length(column_w_names_of_multiple_analytes) > 0 ) {
x <- table(select(data, column_w_names_of_multiple_analytes))
if( all(range(x) / mean(x) != c(1,1)) ) {
stop("There are duplicate analyte names.")
}
}
# Remove analyte annotation columns before pivoting
if( length(columns_w_additional_analyte_info) > 0 ) {
analyte_annotation_free_data <- data[,-match(columns_w_additional_analyte_info, colnames(data))]
} else {
analyte_annotation_free_data <- data
}
matrix
matrix[,-c(1:2)]
matrix <- matrix[,-c(1:2)]
matrix
phylo <- ape::as.phylo(stats::hclust(stats::dist(t(matrix))))
plot(stats::hclust(stats::dist(t(matrix))))
t(matrix)
phylo <- ape::as.phylo(stats::hclust(stats::dist(t(matrix))))
clustering <- ggtree::fortify(phylo)
clustering$sample_unique_ID <- clustering$label
ggtree(clustering)
ggtree(clustering) + geom_tiplab() + coord_cartesian(xlim = c(0,500))
ggtree(clustering) + geom_tiplab() + coord_cartesian(xlim = c(0,250))
plot(stats::hclust(stats::dist(t(matrix))))
ggtree(clustering) + geom_tiplab() + coord_cartesian(xlim = c(0,250))
ggtree(clustering) + geom_tiplab(offset = 10, align = TRUE) + coord_cartesian(xlim = c(0,250))
ggtree(clustering) + geom_tiplab(offset = 10, align = TRUE, geom = "label") + coord_cartesian(xlim = c(0,250))
rowmeans(matrix)
row.means(matrix)
?rowMeans
rowMeans(matrix)
rowMeans(t(matrix))
plot(stats::hclust(stats::dist(t(matrix))))
?rowMeans
rowMeans(t(matrix), na.rm = TRUE)
t(matrix)
plot(stats::hclust(stats::dist(t(matrix))))
matrix), na.rm = TRUE)
# t(matrix)
plot(stats::hclust(stats::dist(t(matrix))))
rowMeans(t(matrix), na.rm = TRUE)
ggtree(clustering) + geom_tiplab(offset = 10, align = TRUE, geom = "label") + coord_cartesian(xlim = c(0,250))
algae_data
solvents
#### libraries
library(tidyverse)
library(ape)
library(ggtree)
#### datasets
algae_data <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/algae_data.csv")
alaska_lake_data <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/alaska_lake_data.csv")
solvents <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/solvents.csv")
periodic_table <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/per_table.csv")
periodic_table_small <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/per_table_small.csv")
NY_trees <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/NY_trees.csv")
ckd_data <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/ckd_metabolomics.csv")
wine_grape_data <- read_csv("https://thebustalab.github.io/R_For_Chemists/sample_data/wine_grape_data.csv")
#### readCSV
#'
readCSV <- function() { return(readr::read_csv(file.choose())) }
#### runMatrixAnalysis
#' Runs a matrix analysis (clustering, kmeans, pca).
#'
#' @param data The data.frame or tibble to use.
#' @param analysis
#' @param column_w_names_of_multiple_analytes
#' @param column_w_values_for_multiple_analytes
#' @param columns_w_values_for_single_analyte
#' @param columns_w_additional_analyte_info
#' @param columns_for_sample_unique_ID
#' @param columns_w_sample_annotation_info
#' @examples
#' @export
#' runMatrixAnalysis
runMatrixAnalysis <-    function(
data,
analysis = c("hclust", "pca", "pca-ord", "pca-dim"),
column_w_names_of_multiple_analytes,
column_w_values_for_multiple_analytes,
columns_w_values_for_single_analyte,
columns_w_additional_analyte_info = NULL,
columns_w_sample_ID_info,
transpose = FALSE
) {
# Check that column names are spelled correctly
if( any(
!c(
column_w_names_of_multiple_analytes,
column_w_values_for_multiple_analytes,
columns_w_values_for_single_analyte,
columns_w_additional_analyte_info,
columns_w_sample_ID_info
) %in% colnames(data)
) == TRUE
) {
stop("There is a mismatch in the column names delivered to the command and the column names in your data. Please double check the spelling of your column names you gave to the command.")
}
# Add analyte_unique_ID_column if necessary
# if( length(columns_for_analyte_unique_ID) > 1 ) {
#add analyte_unique_ID column if necessary
# }
# Remove columns that are not included in input column lists
if (length(
which(!colnames(data) %in%
c(
column_w_names_of_multiple_analytes,
column_w_values_for_multiple_analytes,
columns_w_values_for_single_analyte,
columns_w_additional_analyte_info,
columns_w_sample_ID_info
)
)
) > 0
) {
data <- data[,-which(!colnames(data) %in%
c(
column_w_names_of_multiple_analytes,
column_w_values_for_multiple_analytes,
columns_w_values_for_single_analyte,
columns_w_additional_analyte_info,
columns_w_sample_ID_info
)
)]
}
# Check for duplicate analyte names
if( length(columns_w_values_for_single_analyte) > 0 ) {
if( any(duplicated(columns_w_values_for_single_analyte)) ) {
stop("There are duplicate analyte names.")
}
}
if( length(column_w_names_of_multiple_analytes) > 0 ) {
x <- table(select(data, column_w_names_of_multiple_analytes))
if( all(range(x) / mean(x) != c(1,1)) ) {
stop("There are duplicate analyte names.")
}
}
# Remove analyte annotation columns before pivoting
if( length(columns_w_additional_analyte_info) > 0 ) {
analyte_annotation_free_data <- data[,-match(columns_w_additional_analyte_info, colnames(data))]
} else {
analyte_annotation_free_data <- data
}
# If no pivot required, skip pivoting
if( length(column_w_names_of_multiple_analytes) == 0 & length(columns_w_values_for_single_analyte) >= 1 ) {
data_wide <- analyte_annotation_free_data
analyte_columns <- columns_w_values_for_single_analyte
}
# If pivoting required, pivot_wider any long-style data
if( length(column_w_names_of_multiple_analytes) == 1 ) {
data_wide <- pivot_wider(
analyte_annotation_free_data,
names_from = all_of(column_w_names_of_multiple_analytes),
values_from = all_of(column_w_values_for_multiple_analytes)
)
analyte_columns <- unlist(unique(analyte_annotation_free_data[,colnames(analyte_annotation_free_data) == column_w_names_of_multiple_analytes]))
analyte_columns <- c(columns_w_values_for_single_analyte, analyte_columns)
}
# Convert analyte columns to numeric
which_analyte_columns <- which(colnames(data_wide) %in% analyte_columns)
for( i in which_analyte_columns ) {
data_wide[[i]] <- as.numeric(data_wide[[i]])
}
# Add sample_unique_ID_column if necessary, or just change column name of existing sample_unique_ID column
if( length(columns_w_sample_ID_info) > 1 ) {
sample_unique_IDs <- apply(
data_wide[,match(columns_w_sample_ID_info, colnames(data_wide))],
1, paste, collapse = "_"
)
if( any(duplicated(sample_unique_IDs)) ) {stop("columns_w_sample_ID_info specified do not lead to unique sample IDs")}
data_wide$sample_unique_ID <- sample_unique_IDs
} else {
colnames(data_wide)[colnames(data_wide) == columns_w_sample_ID_info] <- "sample_unique_ID"
if( any(duplicated(data_wide$sample_unique_ID)) ) {stop("columns_w_sample_ID_info specified do not lead to unique sample IDs")}
}
# Make sure "sample_unique_ID" is character
data_wide$sample_unique_ID <- as.character(data_wide$sample_unique_ID)
# Clustering analysis
# Prepare the matrix
matrix <- as.data.frame(data_wide[,match(analyte_columns, colnames(data_wide))])
rownames(matrix) <- data_wide$sample_unique_ID
# Run hclust, if requested
if( analysis == "hclust" ) {
if( transpose == TRUE ) {
phylo <- ape::as.phylo(stats::hclust(stats::dist(t(matrix))))
clustering <- ggtree::fortify(phylo)
clustering$sample_unique_ID <- clustering$label
return(clustering)
stop("Returning transposed cluster output")
} else {
phylo <- ape::as.phylo(stats::hclust(stats::dist(matrix)))
clustering <- ggtree::fortify(phylo)
clustering$sample_unique_ID <- clustering$label
}
}
# Run PCA, if requested
if( analysis == "pca" ) {
coords <- FactoMineR::PCA(matrix, graph = FALSE)$ind$coord[,c(1:2)]
clustering <- as_tibble(coords)
clustering$sample_unique_ID <- rownames(coords)
}
# Run PCA and return ordination plot coordinates, if requested
if( analysis == "pca-ord" ) {
coords <- FactoMineR::PCA(matrix, graph = FALSE)$var$coord[,c(1,2)]
clustering <- as_tibble(coords)
clustering$analyte <- rownames(coords)
clustering <- select(clustering, analyte, Dim.1, Dim.2)
return(clustering)
stop("Returning ordination plot coordinates.")
}
# Run PCA and return eigenvalues, if requested
if( analysis == "pca-dim" ) {
coords <- FactoMineR::PCA(matrix, graph = FALSE)$eig[,2]
clustering <- tibble::enframe(coords, name = NULL)
clustering$principal_component <- names(coords)
clustering$principal_component <- as.numeric(gsub("comp ", "", clustering$principal_component))
colnames(clustering)[colnames(clustering) == "value"] <- "percent_variance_explained"
clustering <- select(clustering, principal_component, percent_variance_explained)
return(clustering)
stop("Returning eigenvalues.")
}
# Add back annotations to the output
clustering <- full_join(
data_wide[,match(
if( length(columns_w_sample_ID_info) == 1 ) {
"sample_unique_ID"
} else {
c(columns_w_sample_ID_info, "sample_unique_ID")
}, colnames(data_wide))],
clustering,
by = "sample_unique_ID"
)
rownames_matrix <- tibble::enframe(rownames(matrix), name = NULL)
colnames(rownames_matrix)[1] <- "sample_unique_ID"
clustering <- full_join(
clustering,
as_tibble(cbind(rownames_matrix, as_tibble(matrix))),
by = "sample_unique_ID"
)
clustering
# Annotate internal branches if tree output
if( analysis == "hclust" ) {
for( node in filter(clustering, isTip == FALSE)$node ) {
for (sample_property in colnames(clustering)[colnames(clustering) %in% columns_w_sample_ID_info] ) {
descends <- clustering[clustering$node %in% descendants(phylo, node),]
if ( table(duplicated(descends[,colnames(descends) == sample_property]))[1] == 1 ) {
clustering[
which(clustering$node == node),
which(colnames(clustering) == sample_property)
] <- descends[,colnames(descends) == sample_property][1,1]
}
}
}
}
# Return results
return( clustering )
}
##### descendants
descendants <- function (phy, node, type = "t", ignore.tip = TRUE, labels = FALSE) {
if (inherits(phy, "phylo")) {
edge <- phy$edge
}
else {
if (!is.matrix(phy)) {
stop("'phy' must be of classes 'phylo' or 'matrix'")
}
else {
edge <- phy
labels <- FALSE
}
}
if (length(node) > 1)
stop("'node' must be vector of length 1")
type <- match.arg(type, c("all", "daughter", "internal",
"terminal"))
tips <- setdiff(edge[, 2], edge[, 1])
if (node <= max(tips)) {
if (ignore.tip) {
x <- node
}
else {
stop("node ", node, " is not an internal node")
}
}
else {
x <- edge[edge[, 1] == node, 2]
if (type %in% c("internal", "terminal", "all")) {
repeat {
xx <- x
x <- sort(unique(c(x, edge[, 2][edge[, 1] %in%
x])))
if (identical(x, xx))
break
}
if (type == "internal")
x <- setdiff(x, tips)
}
}
if (type == "terminal") {
x <- intersect(x, tips)
if (labels) {
x <- phy$tip.label[x]
}
}
x
}
runMatrixAnalysis(
data = alaska_lake_data,
analysis = c("hclust"),
column_w_names_of_multiple_analytes = "element",
column_w_values_for_multiple_analytes = "mg_per_L",
columns_w_values_for_single_analyte = NULL,
columns_w_additional_analyte_info = "element_type",
columns_w_sample_ID_info = c("lake", "park"),
transpose = TRUE
)
?read_csv
?scale_color_gradient
?contour_2d_fill
install.packages("FactoMineR")
FactoMineR::PCA
c(0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6)
seq(0.6, 1.6, 0.1)
seq(1,100,10)
seq(0,100,10)
I've had a look at your submissions for CHEM5725 assignments so far. Please find attached a short video with some feedback. I've also entered the grades for your assignments in Canvas. Overall you are doing an absolutely fantastic job! Thank you for your contributions both in class (discussions, comments in chat, etc.) and out of class (assignments, group assignments, etc.). I am so pleased with your R abilities and I look forward to seeing what you do with them over the course of the semester. Please let me know if you have any questions or comments.
ggplot(data = solvents, aes(x = density, y = specific_gravity)) +
geom_point(aes(size = formula_weight),alpha = 0.7,color = 'turquoise3')+
theme_linedraw()+ geom_smooth(method = "lm", se = FALSE,color = 'black', size = 0.5)
source("https://thebustalab.github.io/R_For_Chemists/custom_functions/chem.R")
ggplot(data = solvents, aes(x = density, y = specific_gravity)) +
geom_point(aes(size = formula_weight),alpha = 0.7,color = 'turquoise3')+
theme_linedraw()+ geom_smooth(method = "lm", se = FALSE,color = 'black', size = 0.5)
ggplot(data = solvents, aes(x = melting_point, y = boiling_point)) +
geom_point(aes(),size = 4, alpha = 0.8,color = 'olivedrab4')+
facet_grid(miscible_with_water~.)+theme_linedraw()
ggplot(data = solvents, aes(x = melting_point, y = boiling_point)) +
geom_point(aes(),size = 4, alpha = 0.8,color = 'olivedrab4')+
facet_grid(miscible_with_water~., scales = "free")+theme_linedraw()+ labs(
title = "Solvent boiling point as a function of melting point",
subtitle = "Top: Solvent immiscible with water. \nBottom: Solvent miscibile with water",
caption = "Note separate ranges for y-axes"
)
ggplot(data = solvents, aes(x = density, y = category)) +
geom_jitter(aes(), height = 0.05,width = 0.1,size = 4, alpha = 0.7,color = 'firebrick3')+theme_classic()
ggplot(data = solvents, aes(x = density, y = category)) +
geom_point(aes(),size = 4, alpha = 0.7,color = 'firebrick3')+theme_classic()
ggplot(data = solvents, aes(x = density, y = refractive_index))+
geom_point(aes(shape = miscible_with_water, color = category, size = vapor_pressure),stroke = 1, alpha = 0.7)+
theme_classic()+
scale_color_viridis_d("Solvent Cateogry") +
scale_shape("Miscible with water",solid=FALSE)+
scale_size("Vapor Pressure",range = c(1, 5))+
scale_x_continuous("Density",breaks = c(0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6))+
scale_y_continuous("Refractive Index")
ggplot(data = solvents, aes(x = formula_weight, y = refractive_index)) +
geom_point(aes(),size = 5,alpha = 0.7,color = 'goldenrod3')+
theme(plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm"),
plot.background = element_rect(fill="cornsilk"),
panel.background = element_rect(fill="white"),
panel.grid.major = element_line(colour = "darkgoldenrod"),
panel.grid.minor = element_line(colour = "darkgoldenrod"))
ggplot(data = solvents, aes(x = melting_point, y = boiling_point)) +
geom_point(aes(),size = 4, alpha = 0.8,color = 'olivedrab4')+
facet_grid(miscible_with_water~., scales = "free")+theme_linedraw()+ labs(
title = "Solvent boiling point as a function of melting point",
subtitle = "Top: Solvent immiscible with water. \nBottom: Solvent miscibile with water",
caption = "Note separate ranges for y-axes"
)
ggplot(data = solvent_data,aes(x=relative_polarity, y = formula_weight))+
geom_point(size=5,color="black")+
geom_smooth(se=FALSE, method=lm)+
labs(title="Relative polarity v Formula weight", x="Relative Polarity", y= "Formula Weight")+
theme_classic()
solvent_data <- solvents
ggplot(data = solvent_data,aes(x=relative_polarity, y = formula_weight))+
geom_point(size=5,color="black")+
geom_smooth(se=FALSE, method=lm)+
labs(title="Relative polarity v Formula weight", x="Relative Polarity", y= "Formula Weight")+
theme_classic()
ggplot(data = solvent_data,aes(x=melting_point, y = boiling_point))+
geom_point(size=5,color="black")+
labs(title="Melting vs Boiling Point by category", x="Melting Point", y= "Boiling Point")+
facet_grid(rows = vars(category))+
theme_bw()
ggplot(data = solvent_data,aes(x=melting_point, y = boiling_point))+
geom_point(size=5,color="black")+
labs(title="Melting vs Boiling Point by category", x="Melting Point", y= "Boiling Point")+
facet_grid(rows = vars(category), scales="free")+
theme_bw()
ggplot(data = solvent_data,aes(x=melting_point, y = boiling_point))+
geom_point(size=5,color="black")+
labs(title="Density vs Refractive Index", x="Density", y= "Refractive Index")+
theme(plot.background = element_rect(fill = "green"))+
theme(panel.grid.major = element_line(colour = "red"))+
theme(plot.title = element_text(size = rel(2)))
ggplot(data = solvent_data,aes(x=melting_point, y = formula_weight))+
geom_point(aes(fill=relative_polarity, size=boiling_point, color=vapor_pressure), shape=21)+
scale_x_continuous(limits = c(-100, -0))+
scale_y_continuous(limits = c(40, 120))+
scale_fill_viridis_c()+
scale_size(range = c(5, 10))+
scale_color_distiller()
labs(title="Solvent properties", x="Melting Point", y= "Formula Weight")+
theme_classic()
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_jitter(aes(color = category)) +
theme(text = element_text(size = 15, color = "navy"),
axis.line = element_line(color = "black"),
legend.background = element_rect(color = "red"), axis.ticks = element_line(size = 3))
solvents_merged <- solvents
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_jitter(aes(color = category)) +
theme(text = element_text(size = 15, color = "navy"),
axis.line = element_line(color = "black"),
legend.background = element_rect(color = "red"), axis.ticks = element_line(size = 3))
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_jitter(aes(color = category, size = boiling_point, alpha = melting_point)) +
geom_rug(aes(color = category)) +
scale_alpha_continuous(range = c(0.2,1)) +
scale_size_continuous(range = c(1,6))
theme_bw()
ggplot(data = solvents_merged, aes(x = density, y = category)
) +
geom_boxplot(aes(color = category))
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_boxplot() +
facet_grid(miscible_with_water~.)
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_boxplot() +
facet_grid(miscible_with_water~., scales = "free")
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_boxplot() +
facet_grid(miscible_with_water~.)
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_boxplot() +
facet_grid(miscible_with_water~., scales = "free")
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_point()
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_jitter()
#Geom_jitter is a useful way to show data without the datapoints being overlapping. Geom_point is a classic way to represent the relationship between two continuous variables.
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_jitter(aes(color = category, size = boiling_point, alpha = melting_point)) +
geom_rug(aes(color = category)) +
scale_alpha_continuous(range = c(0.2,1)) +
scale_size_continuous(range = c(1,6))
theme_bw()
library (tidyverse)
readCSV <- function() { return(readr::read_csv(file.choose())) }
> readCSV()
solvents_merged <- read_csv("solvents_merged.csv")
solvents_merged
ggplot(data = solvents_merged, aes(x = density, y = category)
) +
geom_boxplot(aes(color = category))
#Trend in this dataset shows the relationship between the category
#of solvent and their relative density. It can be seen that chlorinated
#and sulfide containing solvents have higher densities while hydrocarbon
#containing solvents have lower densities.
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_boxplot() +
facet_grid(miscible_with_water~.)
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_boxplot() +
facet_grid(miscible_with_water~., scales = "free")
# A benefit to using the scales = "free" command for the facet_grid function is that R automatically determins the breaks and labels for the axes
# getting rid of data points that are irrelevant. On the other hand without the scales = free command we can see all the possible data, even if it doesn't apply or
# contribute much to the graph
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_point()
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_jitter()
ggplot(data = solvents_merged, aes(x = density, y = category)) +
geom_jitter(aes(color = category)) +
theme(text = element_text(size = 15, color = "navy"),
axis.line = element_line(color = "black"),
legend.background = element_rect(color = "red"), axis.ticks = element_line(size = 3))
ggplot(data=solvent_data,aes(x=melting_point,y=specific_gravity))+
geom_density2d_filled(alpha = 0.9, show.legend=TRUE)+
scale_color_gradient()+
geom_density2d(size = 0.25, colour = "orange")+
theme_dark()+
labs(title="Melting Point Vs. Specific gravity", x="Melting Point", y="Specific gravity", fill="Density")
ggplot(data=solvent_data, aes(x=boiling_point,y=vapor_pressure))+
geom_point(alpha=0.6, aes(color=category, size=relative_polarity)) +
theme_classic()+ facet_grid(.~category) +
labs(title="Vapor Pressure Vs. Boiling Point", x="Boiling Point", y="Vapor Pressure")
ggplot(data=solvent_data, aes(x=boiling_point,y=vapor_pressure))+
geom_point(alpha=0.6, aes(color=category, size=relative_polarity)) +
theme_classic()+ facet_grid(.~category, scales = "free") +
labs(title="Vapor Pressure Vs. Boiling Point", x="Boiling Point", y="Vapor Pressure")
ggplot(data=solvent_data, aes(x=boiling_point,y=vapor_pressure))+
geom_point(alpha = 0.9, aes(color=category, size=relative_polarity))+scale_alpha_continuous() + scale_size_continuous()+
theme(plot.background = element_rect(fill = "blue" ),
panel.grid.major = element_line(colour = "black"),axis.text = element_text(colour = "black")) +
labs(title="Vapor Pressure Vs. Boiling Point", x="Boiling Point", y="Vapor Pressure")
ggplot(data=solvent_data, aes(x=boiling_point,y=vapor_pressure))+
geom_point(alpha = 0.9, aes(color=category, size=relative_polarity))+scale_alpha_continuous() + scale_size_continuous()+
geom_smooth(se=FALSE, color="Black") +
scale_y_log10()+ scale_x_reverse() + scale_color_brewer()+
labs(title="Log(Vapor Pressure) Vs. Boiling Point", x="Boiling Point", y="Log(Vapor Pressure)")
plot8 = ggplot(data = solvents, aes(y = vapor_pressure, x = relative_polarity)) +labs(title='Thematic Analysis', x='Relative Polarity', y="Vapor Pressure")+geom_violin(aes(alpha=relative_polarity), size=4)+theme(panel.background=element_rect(fill="white",color="deepskyblue"),axis.text=element_text(color="blue"), plot.background=element_rect(fill="darkcyan"))
print(plot8)
solvents <- read_csv("C:/Users/Uttam Dominic Gomes/Downloads/solvents.csv")
ggplot(data = solvents, aes(x = boiling_point, y = vapor_pressure))+ geom_point(aes(fill = miscible_with_water, size =category),shape = 21) +  geom_rug(aes(color = formula_weight)) +
theme(axis.text = element_text(color = "blue"),text = element_text(size = 15, color = "red"))
setwd("/Users/lucasbusta/Documents/Science/Website/thebustalab.github.io/R_For_Chemists/")
bookdown::render_book("index.Rmd")
