######################
## GCMS ANALYSIS V1 ##
######################

###### Libraries

    Bioconductor_packages <- c(
        "xcms"
    )
    CRAN_packages <- c("BiocManager", "data.table", "dplyr", "shiny", "shinyjs", "rhandsontable", "ggplot2", "readr", "DT", "tidyr")
    packages_needed <- c(CRAN_packages, Bioconductor_packages)[!c(CRAN_packages, Bioconductor_packages) %in% rownames(installed.packages())]

    ## Determine if anything needs to be installed
        
        if (length(packages_needed) > 0) {

            message <- paste0(
                "You need to install the following packages before proceeding: ",
                paste(packages_needed, collapse = ", "),
                " Is it okay if phylochemistry installs them for you?"
            )

            if (.Platform$OS.type == "unix"){ response <- askYesNo( message ) }

            if (.Platform$OS.type == "windows") { response <- askYesNo("yesnocancel", msg = message) }

            if(response) {
                
                if (length(CRAN_packages[CRAN_packages %in% packages_needed]) > 0) {
                    install.packages(CRAN_packages[CRAN_packages %in% packages_needed], dependencies = TRUE)
                }

                if (length(Bioconductor_packages[Bioconductor_packages %in% packages_needed]) > 0) {
                    BiocManager::install(Bioconductor_packages[Bioconductor_packages %in% packages_needed], dependencies = TRUE)
                }

            } else {
                stop("Cannot load phylochemistry without the required packages. Exiting.")
            }
        }
        
        message("Loading packages...")

        invisible(suppressMessages(suppressWarnings(lapply(c(CRAN_packages, Bioconductor_packages), library, character.only = TRUE))))

###### Functions and Colors

    message("Loading functions...")

    discrete_palette <- c(
        "dodgerblue2", "#E31A1C", # red
        "green4",
        "#6A3D9A", # purple
        "#FF7F00", # orange
        "black", "gold1",
        "skyblue2", "#FB9A99", # lt pink
        "palegreen2",
        "#CAB2D6", # lt purple
        "#FDBF6F", # lt orange
        "gray70", "khaki2",
        "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
        "darkturquoise", "green1", "yellow4", "yellow3",
        "darkorange4", "brown"
    )

    readMonolist <- function( monolist_in_path ) {
        if (length(grep("http", monolist_in_path)) > 0) {
            monolist <- read_csv(monolist_in_path, show_col_types = FALSE)        
        } else {
            monolist <- as.data.frame(data.table::fread(file = monolist_in_path))
        }
        return( monolist )
    }

    writeMonolist <- function( monolist, monolist_out_path, ... ) {
        write.table(monolist, file = monolist_out_path, sep = ",", row.names = FALSE, ...)
        # write_csv(monolist, file = monolist_out_path)
    }

    dropNA <- function( x ) { return(x[!is.na(x)]) }

    #### analyzeGCMSdata

        #' A Shiny app to integrate GC-FID and GC-MS data
        #'
        #' @param chromatograms A data frame containing columns: "rt", "tic", and "path_to_cdf_csv", which contain retention time, total ion chromatogram intensities, and paths to CDF.csv files generated by the convertCDFstoCSVs function.
        #' @param x_axis_start A numeric value for the lower x-axis bounds on the plot generated by the app. Defaults to full length.
        #' @param x_axis_end A numeric value for the upper x-axis bounds on the plot generated by the app. Defaults to full length.
        #' @param samples_monolist_path A path to a .csv file containing metadata for the samples you wish to analyze. Requied columns are: "rt_offset", "baseline_window", and "path_to_cdf_csv", which are for aligning chromatograms, adjusting baseline determination, and defining the path to the CDF.csv files for each sample, respectively.
        #' @param samples_monolist_subset Optional, a numeric vector (for example, "c(1:10)"), defining a subset of samples to be loaded.
        #' @param peaks_monolist_path A path to a .csv file containing metadata for all peaks in the sample set. Required columns are: peak_start", "peak_end", "path_to_cdf_csv", "area", "peak_number_within_sample", "rt_offset", "peak_start_rt_offset", "peak_end_rt_offset". This file is automatically generated by the app.
        #' @param zoom_and_scroll_rate Defines intervals of zooming and scrolling movement while running the app
        #' @examples
        #' @export
        #' analyzeGCMSdata

        analyzeGCMSdata <- function(
                CDF_directory_path = getwd(),
                zoom_and_scroll_rate = 100,
                baseline_window = 400,
                x_axis_start_default = NULL,
                x_axis_end_default = NULL,
                path_to_reference_library = busta_spectral_library,
                samples_monolist_subset = NULL,
                ions = 0,
                jupyter = FALSE
            ) {

                setwd(CDF_directory_path)
                paths_to_cdfs <- dir()[grep("*.CDF$", dir())]
                paths_to_cdf_csvs <- paste0(paths_to_cdfs, ".csv")

                ## PREPARE DATA: Check for CDF to CSV conversion, check chromatograms

                    if ( length(paths_to_cdfs) == 0 ) {

                        stop("The directory specified does not contain any .CDF files.")

                    } else {

                        if ( !file.exists("chromatograms.csv") ) {

                            chromatograms <- list()

                        } else {

                            chromatograms <- readMonolist("chromatograms.csv")

                        }

                        chromatograms_to_add <- list()

                        for (file in 1:length(paths_to_cdfs)) {

                            ## If the cdf.csv doesn't exist for this cdf, create it.

                                if ( !file.exists(paths_to_cdf_csvs[file]) ) {

                                    cat(paste("CDF to CSV conversion. Reading data file ", paths_to_cdfs[file], "\n", sep = ""))
                                        rawDataFile <- xcms::loadRaw(xcms::xcmsSource(paths_to_cdfs[file]))

                                    cat("   Framing data file ... \n")
                                        rt <- rawDataFile$rt
                                        scanindex <- rawDataFile$scanindex

                                        filteredRawDataFile <- list()
                                        for ( i in 1:(length(rt)-1) ) {
                                            filteredRawDataFile[[i]] <- data.frame(
                                                mz = rawDataFile$mz[(scanindex[i]+1):(scanindex[i+1])],
                                                intensity = rawDataFile$intensity[(scanindex[i]+1):(scanindex[i+1])],
                                                rt = rt[i]
                                            )
                                        }
                                        framedDataFile <- do.call(rbind, filteredRawDataFile)
                                        framedDataFile$mz <- round(framedDataFile$mz, digits = 1)
                                        framedDataFile <- drop_na(framedDataFile)

                                    cat("   Merging duplicate rows ...\n")
                                        if ( dim(table(duplicated(paste(framedDataFile$mz, framedDataFile$rt, sep = "_")))) > 1 ) {
                                            framedDataFile %>% group_by(mz,rt) %>% summarize(intensity = sum(intensity), .groups = "drop") -> framedDataFile
                                            framedDataFile <- as.data.frame(framedDataFile)
                                        }

                                    cat("   Writing out data file as CSV... \n")
                                        data.table::fwrite(framedDataFile, file = paste(paths_to_cdfs[file], ".csv", sep = ""), col.names = TRUE, row.names = FALSE)

                                }

                            ## If any chromatograms (tic and ion) are not present for this csv, extract them

                                if ( file.exists("chromatograms.csv") ) {

                                    ions_for_this_cdf_csv <- unique(filter(readMonolist("chromatograms.csv"), path_to_cdf_csv == paths_to_cdf_csvs[file])$ion)
                                    missing_ions <- as.numeric(as.character(ions[!ions %in% ions_for_this_cdf_csv])) ## Here as numeric mess with TIC
                                    missing_ions <- dropNA(missing_ions)

                                } else {

                                    missing_ions <- ions

                                }

                                if (length(missing_ions) > 0) {
                                    
                                    cat(paste("Chromatogram extraction. Reading data file ", paths_to_cdf_csvs[file], "\n", sep = ""))    
                                        framedDataFile <- as.data.frame(data.table::fread(paths_to_cdf_csvs[file]))
                                    
                                    cat("   Extracting chromatograms...\n")
                                        
                                        if (0 %in% ions) {
                                            framedDataFile$row_number <- seq(1,dim(framedDataFile)[1],1)
                                            framedDataFile %>% 
                                                group_by(rt) %>% summarize(
                                                abundance = sum(intensity),
                                                ion = 0,
                                                rt_first_row_in_raw = min(row_number),
                                                rt_last_row_in_raw = max(row_number)
                                            ) -> chromatogram
                                            chromatogram <- as.data.frame(chromatogram)
                                            chromatogram$rt <- as.numeric(chromatogram$rt)
                                            chromatogram$path_to_cdf_csv <- paste(paths_to_cdfs[file], ".csv", sep = "")
                                            chromatograms_to_add <- rbind(chromatograms_to_add, chromatogram)
                                        }

                                        if ( length(ions[ions != 0]) > 0 ) {

                                            numeric_ions <- as.numeric(as.character(ions[ions != 0]))
                                            for ( ion in 1:length(numeric_ions) ){
                                                framedDataFile$row_number <- seq(1,dim(framedDataFile)[1],1)
                                                framedDataFile %>% 
                                                    group_by(rt) %>% 
                                                    filter(mz > (numeric_ions[ion] - 0.6)) %>%
                                                    filter(mz < (numeric_ions[ion] + 0.6)) -> signal
                                                    summarize(signal,
                                                        abundance = sum(intensity),
                                                        ion = numeric_ions[ion],
                                                        rt_first_row_in_raw = if (dim(signal)[1] > 0) { min(row_number) } else { 0 },
                                                        rt_last_row_in_raw = if (dim(signal)[1] > 0) { max(row_number) } else { 0 }
                                                    ) -> chromatogram
                                                chromatogram <- as.data.frame(chromatogram)
                                                chromatogram$rt <- as.numeric(chromatogram$rt)

                                                if (dim(signal)[1] > 0) { 
                                                    chromatogram$path_to_cdf_csv <- paste(paths_to_cdfs[file], ".csv", sep = "")
                                                    chromatograms_to_add <- rbind(chromatograms_to_add, chromatogram)   
                                                }
                                            }
                                        }
                                }

                            ## If the chromatograms file already exists, append to it and re-write out, else create it

                                if ( file.exists("chromatograms.csv") ) {
                                    
                                    # print("writing it")

                                    writeMonolist(
                                        monolist = rbind( chromatograms, chromatograms_to_add ),
                                        monolist_out_path = "chromatograms.csv"
                                    )

                                } else {

                                    writeMonolist(chromatograms_to_add, "chromatograms.csv")

                                }
                        }

                        print("done")
                    }

                    ## Read in chromatograms

                        chromatograms <- readMonolist("chromatograms.csv")
                                
                    ## Set up new samples monolist

                        ## If it doesn't exist, create it
                        
                            if ( !file.exists("samples_monolist.csv") ) {

                                samples_monolist <- data.frame(
                                    Sample_ID = unique(chromatograms$path_to_cdf_csv),
                                    rt_offset = 0,
                                    baseline_window = baseline_window,
                                    path_to_cdf_csv = unique(chromatograms$path_to_cdf_csv)
                                )

                                write.table(
                                    x = samples_monolist,
                                    file = "samples_monolist.csv",
                                    row.names = FALSE,
                                    sep = ","
                                )

                        # If it exists, check to see if all cdfs in this folder are in it, if not, add them

                            } else {

                                samples_monolist <- readMonolist("samples_monolist.csv")

                                missing_from_samples_monolist <- paths_to_cdf_csvs[!paths_to_cdf_csvs %in% unique(readMonolist("samples_monolist.csv")$path_to_cdf_csv)]

                                if ( length(missing_from_samples_monolist) > 0 ) {

                                    samples_monolist_additions <- data.frame(
                                        Sample_ID = gsub("\\..*$", "", gsub(".*/", "", missing_from_samples_monolist)),
                                        rt_offset = 0,
                                        baseline_window = baseline_window,
                                        path_to_cdf_csv = missing_from_samples_monolist
                                    )

                                    write.table(
                                        x = samples_monolist_additions,
                                        file = "samples_monolist.csv",
                                        row.names = FALSE,
                                        col.names = FALSE,
                                        sep = ",",
                                        append = TRUE
                                    )
                                }
                            }

                    ## Filter chromatograms so only the CDFs in this folder are included

                        chromatograms <- chromatograms[chromatograms$path_to_cdf_csv %in% dir()[grep(".CDF.csv", dir())],]

                    ## Set up several variables, plot_height, and x_axis limits if not specified in function call
                        
                        peak_data <- NULL
                        peak_points <- NULL
                        plot_height <- 200 + 100*length(unique(chromatograms$path_to_cdf_csv))
                        
                    ## Set up new peak monolist if it doesn't exist
                    
                    if ( !file.exists("peaks_monolist.csv") ) {
                        
                        peak_data <- data.frame(
                          peak_start = 0,
                          peak_end = 0,
                          peak_ID = "unknown",
                          path_to_cdf_csv = "a",
                          area = 0
                        )

                        write.table(
                          x = peak_data[-1,],
                          file = "peaks_monolist.csv",
                          append = FALSE,
                          row.names = FALSE,
                          col.names = TRUE,
                          sep = ","
                        )

                    }

                ## SET UP USER INTERFACE

                    ui <- fluidPage(

                        tags$script('
                        $(document).on("keypress", function (e) {
                           Shiny.onInputChange("keypress", e.which);
                        });
                        '), 

                        tabsetPanel(type = "tabs",

                            tabPanel("Main",

                                verticalLayout(

                                    plotOutput(
                                        outputId = "massSpectra_1",
                                        brush = brushOpts(
                                            id = "massSpectra_1_brush"
                                        ),
                                        height = 150
                                    ),

                                    plotOutput(
                                        outputId = "massSpectra_2",
                                        brush = brushOpts(
                                            id = "massSpectra_2_brush"
                                        ),
                                        height = 150
                                    ),

                                    plotOutput(
                                        outputId = "chromatograms",
                                        brush = brushOpts(
                                            id = "chromatogram_brush"
                                        ),
                                      click = "chromatogram_click", 
                                      dblclick = "chromatogram_double_click",
                                      height = plot_height
                                    ),

                                    verbatimTextOutput("key", placeholder = TRUE),

                                    rhandsontable::rHandsontableOutput("peak_table")
                                ),

                                tags$head(
                                    HTML(
                                        "
                                        <script>
                                            var socket_timeout_interval
                                            var n = 0
                                            $(document).on('shiny:connected', function(event) {
                                            socket_timeout_interval = setInterval(function(){
                                            Shiny.onInputChange('count', n++)
                                            }, 15000)
                                            });
                                            $(document).on('shiny:disconnected', function(event) {
                                            clearInterval(socket_timeout_interval)
                                            });
                                        </script>
                                        "
                                    )
                                ),

                                textOutput("keepAlive")
                            ),

                            tabPanel("MS Library",

                                verticalLayout(
                                    
                                    plotOutput(
                                        outputId = "massSpectrumLookup",
                                        height = 1200
                                    )

                                )
                            )
                        )
                    )

                ## SET UP SERVER

                    server <- function(input, output, session) {

                        ## Don't let it time out
                            output$keepAlive <- renderText({
                                req(input$count)
                                paste("\nstayin' alive ", input$count)
                            })

                        ## Check keystoke value
                            output$key <- renderPrint({
                                input$keypress
                            })

                        ## Keys to move chromatogram view - zoom in and out, move L and R
                            observeEvent(input$keypress, {
                                if( input$keypress == 70 ) { x_axis_start_default <<- x_axis_start_default + zoom_and_scroll_rate } # Forward on "F"
                                if( input$keypress == 70 ) { x_axis_end_default <<- x_axis_end_default + zoom_and_scroll_rate } # Forward on "F"
                                if( input$keypress == 68 ) { x_axis_start_default <<- x_axis_start_default - zoom_and_scroll_rate } # Backward on "D"
                                if( input$keypress == 68 ) { x_axis_end_default <<- x_axis_end_default - zoom_and_scroll_rate } # Backward on "D"
                                if( input$keypress == 86 ) { x_axis_start_default <<- x_axis_start_default - zoom_and_scroll_rate } # Wider on "V"
                                if( input$keypress == 86 ) { x_axis_end_default <<- x_axis_end_default + zoom_and_scroll_rate } # Wider on "V"
                                if( input$keypress == 67 ) { x_axis_start_default <<- x_axis_start_default + zoom_and_scroll_rate } # Closer on "C"
                                if( input$keypress == 67 ) { x_axis_end_default <<- x_axis_end_default - zoom_and_scroll_rate } # Closer on "C"
                            })

                        ## Save manual changes to table on "Z" (90) keystroke

                            observeEvent(input$keypress, {

                                if (input$keypress == 90 ) {

                                    ## Write out any modifications to peak table (i.e. sample IDs)
                                        
                                        hot = isolate(input$peak_table)
                                        if (!is.null(hot)) {
                                            writeMonolist(rhandsontable::hot_to_r(input$peak_table), "peaks_monolist.csv")
                                            cat("Peak list saved!\n")
                                        }

                                }
                            
                            })

                        ## Update chromatogram on "Q" (81) keystroke
                            
                            observeEvent(input$keypress, {      
                                
                                if( input$keypress == 81 ) { # Update on "Q"

                                    ## Read in samples monolist and put chromatograms into chromatograms_updated
                                        
                                        samples_monolist <- read.csv("samples_monolist.csv")
                                        if ( length(samples_monolist_subset) > 0 ) {
                                            samples_monolist <- samples_monolist[samples_monolist_subset,]    
                                        }
                                        chromatograms_updated <- dplyr::filter(chromatograms, path_to_cdf_csv %in% samples_monolist$path_to_cdf_csv)

                                    ## Calculate baseline for each sample

                                        baselined_chromatograms <- list()

                                        for ( chrom in 1:length(unique(chromatograms_updated$path_to_cdf_csv)) ) {
                                  
                                            chromatogram <- dplyr::filter(chromatograms_updated, path_to_cdf_csv == unique(chromatograms_updated$path_to_cdf_csv)[chrom])
                                            tic <- filter(chromatogram, ion == 0)

                                            prelim_baseline_window <- samples_monolist$baseline_window[match(chromatogram$path_to_cdf_csv[1], samples_monolist$path_to_cdf_csv)]

                                            n_prelim_baseline_windows <- floor(length(tic$rt)/prelim_baseline_window)
                                            prelim_baseline <- list()
                                            for ( i in 1:n_prelim_baseline_windows ) {
                                                abundances_in_window <- tic$abundance[((prelim_baseline_window*(i-1))+1):(prelim_baseline_window*i)]
                                                prelim_baseline[[i]] <- data.frame(
                                                    rt = tic$rt[(which.min(abundances_in_window)+((i-1)*prelim_baseline_window))],
                                                    min = min(abundances_in_window)
                                                )
                                            }
                                            prelim_baseline <- do.call(rbind, prelim_baseline)
                                            tic$in_prelim_baseline <- FALSE
                                            tic$in_prelim_baseline[tic$rt %in% prelim_baseline$rt] <- TRUE

                                            y = prelim_baseline$min
                                            x = prelim_baseline$rt

                                            baseline2 <- data.frame(
                                                rt = tic$rt,
                                                y = approx(x, y, xout = tic$rt)$y
                                            )
                                            baseline2 <- baseline2[!is.na(baseline2$y),]
                                            tic <- tic[tic$rt %in% baseline2$rt,]
                                            tic$baseline <- baseline2$y

                                            baselined_chromatograms[[chrom]] <- data.frame(
                                                rt = tic$rt,
                                                abundance = tic$baseline,
                                                ion = "baseline",
                                                path_to_cdf_csv = tic$path_to_cdf_csv,
                                                rt_first_row_in_raw = tic$rt_first_row_in_raw,
                                                rt_last_row_in_raw = tic$rt_last_row_in_raw
                                            )
                                        }

                                        baselined_chromatograms <- do.call(rbind, baselined_chromatograms)
                                        chromatograms_updated <- rbind(chromatograms, baselined_chromatograms)

                                    ## Add rt offset information for all chromatograms

                                        chromatograms_updated$rt_offset <- samples_monolist$rt_offset[match(chromatograms_updated$path_to_cdf_csv, samples_monolist$path_to_cdf_csv)]
                                        chromatograms_updated$rt_rt_offset <- chromatograms_updated$rt + chromatograms_updated$rt_offset
                                        chromatograms_updated <<- chromatograms_updated

                                    ## Subset x_axis according to selection in chromatogram

                                        ## If null from initial start up, assign extreme values

                                            if ( is.null(x_axis_start_default) ) {
                                                x_axis_start_default <<- min(chromatograms$rt)
                                                cat(paste("x_axis_start_default is ", x_axis_start_default, "\n"))
                                            }

                                            if ( is.null(x_axis_end_default) ) {
                                                x_axis_end_default <<- max(chromatograms$rt)
                                                cat(paste("x_axis_end_default is ", x_axis_end_default, "\n"))
                                            }

                                        ## If brush is null, assign default values to start and end

                                            if ( is.null(input$chromatogram_brush) ) {
                                                x_axis_start <<- x_axis_start_default
                                                x_axis_end <<- x_axis_end_default
                                                y_axis_end <<- max(chromatograms$abundance)
                                            }

                                        ## If brush is not null, assign brush values to start and end

                                            if ( !is.null(input$chromatogram_brush) ) {
                                                peak_points <<- isolate(brushedPoints(chromatograms_updated, input$chromatogram_brush))
                                                x_axis_start <<- min(peak_points$rt)
                                                x_axis_end <<- max(peak_points$rt)
                                                y_axis_end <<- max(peak_points$abundance)
                                                # x_axis_end <<- max(peak_points$rt)
                                            }
                                        
                                        ## Filter chromatogram
                                            
                                            chromatograms_updated_filtered <- dplyr::filter(
                                                chromatograms_updated, rt_rt_offset > x_axis_start & rt_rt_offset < x_axis_end
                                            )

                                    ## Plot
                                            
                                        facet_labels <- gsub(".CDF.csv", "", gsub(".*/", "", chromatograms_updated_filtered$path_to_cdf_csv))
                                        names(facet_labels) <- chromatograms_updated_filtered$path_to_cdf_csv

                                        chromatogram_plot <- ggplot() +
                                            geom_line(
                                                data = filter(chromatograms_updated_filtered, ion == "baseline"),
                                                mapping = aes(x = rt_rt_offset, y = abundance), color = "grey"
                                            ) +
                                            scale_x_continuous(limits = c(x_axis_start, x_axis_end), name = "Retention (Scan number)") +
                                            scale_y_continuous(limits = c(0, y_axis_end), name = "Abundance (counts)", oob = scales::squish) +
                                            facet_grid(path_to_cdf_csv~., scales = "free_y", labeller = labeller(path_to_cdf_csv = facet_labels)) +
                                            theme_classic() +
                                            guides(fill = "none") +
                                            scale_fill_continuous(type = "viridis") +
                                            scale_color_manual(values = discrete_palette)

                                    ## Add peaks, if any
                                        
                                        peak_table <- read.csv("peaks_monolist.csv")
                                
                                        if (dim(peak_table)[1] > 0) {

                                            ## Filter out duplicate peaks and NA peaks
                                                
                                                peak_table <- peak_table %>% group_by(path_to_cdf_csv) %>% mutate(duplicated = duplicated(peak_start))
                                                peak_table <- as.data.frame(peak_table)
                                                peak_table <- dplyr::filter(peak_table, duplicated == FALSE)
                                                peak_table <- peak_table %>% group_by(path_to_cdf_csv) %>% mutate(duplicated = duplicated(peak_end))
                                                peak_table <- as.data.frame(peak_table)
                                                peak_table <- dplyr::filter(peak_table, duplicated == FALSE)
                                                peak_table <- peak_table[,!colnames(peak_table) == "duplicated"]
                                                peak_table <- peak_table[!is.na(peak_table$peak_start),]

                                            ## Update with peak_number_within_sample
                                                
                                                peak_table_updated <- list()
                                                for (sample_number in 1:length(unique(peak_table$path_to_cdf_csv))) {
                                                  peaks_in_this_sample <- peak_table[peak_table$path_to_cdf_csv == unique(peak_table$path_to_cdf_csv)[sample_number],]
                                                  peaks_in_this_sample <- peaks_in_this_sample[order(peaks_in_this_sample$peak_start),]
                                                  peaks_in_this_sample$peak_number_within_sample <- seq(1,length(peaks_in_this_sample$path_to_cdf_csv),1)
                                                  peak_table_updated[[sample_number]] <- peaks_in_this_sample
                                                }
                                                peak_table_updated <- do.call(rbind, peak_table_updated)
                                                peak_table <- peak_table_updated

                                            ## Modify peaks with RT offset

                                                peak_table$rt_offset <- samples_monolist$rt_offset[match(peak_table$path_to_cdf_csv, samples_monolist$path_to_cdf_csv)]
                                                peak_table$peak_start_rt_offset <- peak_table$peak_start + peak_table$rt_offset
                                                peak_table$peak_end_rt_offset <- peak_table$peak_end + peak_table$rt_offset
                                                peak_table$path_to_cdf_csv <- as.character(peak_table$path_to_cdf_csv)
                                    
                                            ## Update all peak areas in case baseline was adjusted
                                                
                                                for (sample_number in 1:length(unique(samples_monolist$path_to_cdf_csv))) {
                                                  
                                                  peaks_in_this_sample <- peak_table[peak_table$path_to_cdf_csv == samples_monolist$path_to_cdf_csv[sample_number],]
                                                  
                                                  areas <- vector()
                                                  for (peak in 1:length(peaks_in_this_sample$peak_number_within_sample)) {
                                                    areas <- append(areas, 
                                                      sum(dplyr::filter(
                                                        chromatograms_updated[chromatograms_updated$path_to_cdf_csv == as.character(peaks_in_this_sample$path_to_cdf_csv[peak]),], 
                                                        rt >= peaks_in_this_sample$peak_start[peak] & rt <= peaks_in_this_sample$peak_end[peak],
                                                        ion == 0)$abundance
                                                      ) - 
                                                      sum(dplyr::filter(
                                                        chromatograms_updated[chromatograms_updated$path_to_cdf_csv == as.character(peaks_in_this_sample$path_to_cdf_csv[peak]),], 
                                                        rt >= peaks_in_this_sample$peak_start[peak] & rt <= peaks_in_this_sample$peak_end[peak])$baseline
                                                      )
                                                    )
                                                  }

                                                  peak_table$area[peak_table$path_to_cdf_csv == as.character(samples_monolist$path_to_cdf_csv[sample_number])] <- areas

                                                }
                                  
                                            ## Write out peaks now with assigned peak_number_within_sample and RT offset, update the peak_table in ui
                                    
                                                write.table(peak_table, file = "peaks_monolist.csv", col.names = TRUE, sep = ",", row.names = FALSE)

                                                output$peak_table <- rhandsontable::renderRHandsontable(rhandsontable::rhandsontable({
                                                    peak_table2 <- read.csv("peaks_monolist.csv")
                                                    peak_table2
                                                }))

                                            ## Add peaks

                                                print(x_axis_start)
                                                print(x_axis_end)
                                                if (length(x_axis_start) == 0) {x_axis_start <<- min(chromatograms$rt)}
                                                if (length(x_axis_end) == 0) {x_axis_end <<- max(chromatograms$rt)}
                                                print(x_axis_start)
                                                print(x_axis_end)

                                                peak_table <- dplyr::filter(peak_table, peak_start_rt_offset > x_axis_start & peak_end_rt_offset < x_axis_end)

                                                for (peak in 1:dim(peak_table)[1]) {
                                                    signal_for_this_peak <- dplyr::filter(
                                                        chromatograms_updated[chromatograms_updated$path_to_cdf_csv == peak_table[peak,]$path_to_cdf_csv,], 
                                                        rt_rt_offset > peak_table[peak,]$peak_start_rt_offset, 
                                                        rt_rt_offset < peak_table[peak,]$peak_end_rt_offset
                                                    )
                                                    if (dim(signal_for_this_peak)[1] > 0) {

                                                        signal_for_this_peak$peak_number_within_sample <- peak_table$peak_number_within_sample[peak]
                                                        ribbon <- filter(signal_for_this_peak, ion == 0)
                                                        ribbon$baseline <- filter(signal_for_this_peak, ion == "baseline")$abundance
                                                        chromatogram_plot <- chromatogram_plot +
                                                            geom_vline(data = signal_for_this_peak[1,], mapping = aes(xintercept = rt_rt_offset), alpha = 0.3) +
                                                            geom_ribbon(
                                                                data = ribbon,
                                                                mapping = aes(x = rt_rt_offset, ymax = abundance, ymin = baseline, fill = peak_number_within_sample),
                                                                alpha = 0.8
                                                            ) +
                                                            geom_text(
                                                                data = filter(signal_for_this_peak, ion == 0),
                                                                mapping = aes(label = peak_number_within_sample, x = median(rt_rt_offset), y = max(abundance))
                                                            )
                                                    }
                                                }

                                        }

                                    ## Draw the plot and communicate

                                        chromatogram_plot <- chromatogram_plot +
                                            geom_line(
                                                data = filter(chromatograms_updated, ion != "baseline"),
                                                mapping = aes(x = rt_rt_offset, y = abundance, color = ion),
                                                alpha = 0.8
                                            )
                                        output$chromatograms <- renderPlot({chromatogram_plot})

                                        cat("Chromatogram updated.\n")
                                }
                            })

                        ## Transfer chromatogram_brush info to selected_peak table
                            
                            output$selected_peak <- DT::renderDataTable(DT::datatable({

                                if ( !is.null(input$chromatogram_brush )) {
                                    peak_points <- brushedPoints(chromatograms_updated, input$chromatogram_brush)
                                    peak_data <-  data.frame(
                                        peak_start = min(peak_points$rt),
                                        peak_end = max(peak_points$rt),
                                        peak_ID = "unknown",
                                        path_to_cdf_csv = peak_points$path_to_cdf_csv[1],
                                        area = sum(peak_points$abundance[peak_points$ion == 0])
                                    )
                                    peak_data
                                } else {
                                    NULL
                                }

                            }))

                        ## Remove selected peaks with "R" (82) keystroke
                            
                            observeEvent(input$keypress, {
                                if( input$keypress == 82 ) { # Update on "R"

                                    if ( !is.null(input$chromatogram_brush )) {

                                        peak_points <- brushedPoints(chromatograms_updated, input$chromatogram_brush)
                                        selection_start = min(peak_points$rt)
                                        selection_end = max(peak_points$rt)
                                        path_to_cdf_csv = peak_points$path_to_cdf_csv[1]
                                        peak_table <- read.csv("peaks_monolist.csv")

                                        peak_table <- peak_table[
                                            !apply(cbind(
                                                peak_table$peak_start > selection_start,
                                                peak_table$peak_end < selection_end,
                                                peak_table$path_to_cdf_csv == as.character(peak_points$path_to_cdf_csv[1])
                                            ), 1, all)
                                        ,]

                                        write.table(
                                            x = peak_table,
                                            file = "peaks_monolist.csv",
                                            append = FALSE,
                                            row.names = FALSE,
                                            col.names = TRUE,
                                            sep = ","
                                        )
                                        cat("Removed peaks.\n")
                                    }
                                }
                            })

                        ## Append single peak with "A" (65) keystroke 
                            
                            observeEvent(input$keypress, {

                                # Do nothing if no selection
                                    if(is.null(input$chromatogram_brush)) {
                                        return()
                                    }

                                # If selection and "a" is pressed, add the selection to the peak table
                                    if( input$keypress == 65 ) {
                                    
                                        write.table(
                                            x = data.frame(
                                                    peak_start = min(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt),
                                                    peak_end = max(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt),
                                                    peak_ID = "unknown",
                                                    path_to_cdf_csv = brushedPoints(chromatograms_updated, input$chromatogram_brush)$path_to_cdf_csv[1],
                                                    area = sum(brushedPoints(chromatograms_updated, input$chromatogram_brush)$tic) - sum(brushedPoints(chromatograms_updated, input$chromatogram_brush)$baseline)
                                                ),
                                            file = "peaks_monolist.csv",
                                            append = TRUE,
                                            row.names = FALSE,
                                            col.names = FALSE,
                                            sep = ","
                                        )

                                        output$peak_table <- rhandsontable::renderRHandsontable(rhandsontable::rhandsontable({
                                            peak_table2 <- read.csv("peaks_monolist.csv")
                                            peak_table2
                                        }))
                                        cat("Added peak.\n")
                                    }
                            })

                        ## Global append peak with "G" (71) keystroke

                            observeEvent(input$keypress, {

                                # Do nothing if no selection
                                    if(is.null(input$chromatogram_brush)) {
                                        return()
                                    }

                                # If selection and "G" is pressed, add the selection to the peak table
                                    if( input$keypress == 71 ) {
                                    
                                        x_peaks <-  data.frame(
                                                        peak_start = min(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt_rt_offset),
                                                        peak_end = max(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt_rt_offset),
                                                        peak_ID = "unknown",
                                                        path_to_cdf_csv = unique(chromatograms_updated$path_to_cdf_csv),
                                                        area = sum(brushedPoints(chromatograms_updated, input$chromatogram_brush)$tic) - sum(brushedPoints(chromatograms_updated, input$chromatogram_brush)$baseline)
                                                    )

                                        x_peaks$peak_start <- x_peaks$peak_start - chromatograms_updated$rt_offset[match(x_peaks$path_to_cdf_csv, chromatograms_updated$path_to_cdf_csv)]
                                        x_peaks$peak_end <- x_peaks$peak_end - chromatograms_updated$rt_offset[match(x_peaks$path_to_cdf_csv, chromatograms_updated$path_to_cdf_csv)]

                                        write.table(
                                            x = x_peaks,
                                            file = "peaks_monolist.csv",
                                            append = TRUE,
                                            row.names = FALSE,
                                            col.names = FALSE,
                                            sep = ","
                                        )

                                        output$peak_table <- DT::renderDataTable(DT::datatable({
                                            peak_table <- read.csv("peaks_monolist.csv")
                                            peak_table
                                        }))
                                        cat("Added global peak.\n")
                                    }
                            })

                        ## [MS1 extract ("shift+1"), update ("shift+2"), subtract ("shift+3"), library search ("shift+4"), save ("shift+5")]
                            
                            observeEvent(input$keypress, {

                                ## If "shift+1", MS from chromatogram brush -> MS_out_1
                                    
                                    if( input$keypress == 33 ) {

                                        ret_start_MS <- min(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt)
                                        ret_end_MS <- max(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt)
                                        sample_name_MS <- as.character(brushedPoints(chromatograms_updated, input$chromatogram_brush)$path_to_cdf_csv[1])

                                        chromatogram_updated_MS <- filter(chromatograms_updated, path_to_cdf_csv == sample_name_MS)

                                        MS_ret_start_line <<- chromatogram_updated_MS$rt_first_row_in_raw[which.min(abs(
                                            chromatogram_updated_MS$rt - ret_start_MS
                                        ))] + 1

                                        MS_ret_end_line <<- chromatogram_updated_MS$rt_last_row_in_raw[which.min(abs(
                                            chromatogram_updated_MS$rt - ret_end_MS
                                        ))] + 1

                                        if (.Platform$OS.type == "unix") {
                                            
                                            system(paste0("head -1"," ",CDF_directory_path,"/",sample_name_MS," > ",CDF_directory_path,"/temp_MS.csv"))
                                            system(paste0("sed -n ",MS_ret_start_line,",",MS_ret_end_line,"p ",sample_name_MS," >> ",CDF_directory_path,"/temp_MS.csv"))    
                                            framedDataFile <- readMonolist(paste0(CDF_directory_path, "/temp_MS.csv"))  
                                        
                                        }

                                        if (.Platform$OS.type == "windows") {
                                            
                                            # system(paste0("head -1"," ",CDF_directory_path,"/",sample_name_MS," > ",CDF_directory_path,"/temp_MS.csv"))
                                            # system(paste0("sed -n ",MS_ret_start_line,",",MS_ret_end_line,"p ",sample_name_MS," >> ",CDF_directory_path,"/temp_MS.csv"))    
                                            framedDataFile <-   isolate(
                                                as.data.frame(
                                                    data.table::fread(sample_name_MS)
                                                )
                                            )
                                        
                                        }

                                        framedDataFile <- isolate(dplyr::filter(framedDataFile, rt > ret_start_MS, rt < ret_end_MS))
                                        framedDataFile$mz <- round(framedDataFile$mz, 1)
                                        framedDataFile <- framedDataFile %>% group_by(mz) %>% summarize(intensity = sum(intensity))
                                        MS_out_1 <<- as.data.frame(framedDataFile)
                                    }

                                ## If "shift+3" subtract chromatogram brush from MS_out_1 -> MS_out_1

                                    if ( input$keypress == 35 ) {

                                        if (!exists("MS_out_1")) {
                                            cat("No mass spectrum extracted yet.\n")
                                            return()
                                        } else {
                                        
                                            framedDataFile_to_subtract <- isolate(as.data.frame(
                                                                data.table::fread(as.character(
                                                                    brushedPoints(chromatograms_updated, input$chromatogram_brush)$path_to_cdf_csv[1]
                                                                ))
                                            ))
                                            framedDataFile_to_subtract <- isolate(dplyr::filter(
                                                                    framedDataFile_to_subtract, 
                                                                    rt > min(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt),
                                                                    rt < max(brushedPoints(chromatograms_updated, input$chromatogram_brush)$rt)
                                                                ))
                                            framedDataFile_to_subtract$mz <- round(framedDataFile_to_subtract$mz, 1)
                                            framedDataFile_to_subtract <- framedDataFile_to_subtract %>% group_by(mz) %>% summarize(intensity = sum(intensity))
                                            framedDataFile_to_subtract <<- as.data.frame(framedDataFile_to_subtract)
                                            joined <- left_join(MS_out_1, framedDataFile_to_subtract, by = "mz")
                                            joined$intensity.y[is.na(joined$intensity.y)] <- 0
                                            MS_out_1$intensity <- joined$intensity.x - joined$intensity.y
                                            MS_out_1$intensity[MS_out_1$intensity < 0] <- 0
                                            MS_out_1 <<- MS_out_1
                                        }
                                    }

                                ## If "shift+1", or "shift+2", or "shift+3, make plot based on brush if any

                                    if ( input$keypress == 33 | input$keypress == 64 | input$keypress == 35 ) {

                                        if (!exists("MS_out_1")) {
                                            cat("No mass spectrum extracted yet.\n")
                                            return()
                                        } else {

                                            # Normalize to max abu 100
                                                MS_out_1$intensity <- MS_out_1$intensity*100/max(MS_out_1$intensity)

                                            # Set ranges on mass spec (allow zooming in with selection), Sometimes brush returns Inf or -Inf if the range gets too small, so if that happens, just go up to the main view
                                        
                                                if (isolate(is.null(input$massSpectra_1_brush))) {
                                                    MS1_low_x_limit <- 0; MS1_high_x_limit <- 1200; MS1_high_y_limit <- 110
                                                } else {
                                                    MS1_low_x_limit <- isolate(min(brushedPoints(MS_out_1, input$massSpectra_1_brush)$mz))
                                                    MS1_high_x_limit <- isolate(max(brushedPoints(MS_out_1, input$massSpectra_1_brush)$mz))
                                                    MS1_high_y_limit <- max(dplyr::filter(MS_out_1, mz > MS1_low_x_limit & mz < MS1_high_x_limit)$intensity) + 8
                                                }
                                                if (MS1_low_x_limit %in% c(Inf, -Inf) | MS1_high_x_limit %in% c(Inf, -Inf) | MS1_high_y_limit %in% c(Inf, -Inf)) {
                                                    MS1_low_x_limit <- 0; MS1_high_x_limit <- 1200; MS1_high_y_limit <- 110
                                                }

                                            # Make plot

                                                output$massSpectra_1 <- renderPlot({

                                                    ggplot() + 
                                                        geom_bar(
                                                            data = MS_out_1,
                                                            mapping = aes(x = mz, y = intensity),
                                                            stat = "identity", width = 0.1,
                                                            color = "black", fill = "grey"
                                                        ) +
                                                        theme_classic() +
                                                        scale_x_continuous(expand = c(0,0)) +
                                                        scale_y_continuous(expand = c(0,0)) +
                                                        coord_cartesian(xlim = c(MS1_low_x_limit, MS1_high_x_limit), ylim = c(0, MS1_high_y_limit)) +
                                                        geom_text(
                                                            data = # If it's less than 10 bars, label all. Otherwise, label 10 biggest ones
                                                                if (MS1_high_x_limit - MS1_low_x_limit >= 1) {
                                                                    dplyr::filter(MS_out_1, mz > MS1_low_x_limit & mz < MS1_high_x_limit)[
                                                                        order(
                                                                            dplyr::filter(MS_out_1, mz > MS1_low_x_limit & mz < MS1_high_x_limit)$intensity,
                                                                            decreasing = TRUE
                                                                        )[1:10]
                                                                    ,]
                                                                } else {
                                                                    MS_out_1
                                                                },
                                                            mapping = aes(x = mz, y = intensity + 5, label = mz)
                                                        )
                                                })
                                        }
                                    }

                            })

                    }

                ## Call the app

                    shinyApp(ui = ui, server = server)
        }

message("Done!")
