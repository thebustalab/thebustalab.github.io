"scale_variance",
"na_replacement",
"output_format",
"..."
))
) {stop("One of your argument names is misspelled, please double check spelling.")}
# Check that column names are spelled correctly
if( any(
!c(
columns_w_values_for_single_analyte,
columns_w_sample_ID_info
) %in% colnames(data)
) == TRUE
) {
stop("There is a mismatch in the column names delivered to the command and the column names in your data. Please double check the spelling of your column names you gave to the command.")
}
if (all(c(
is.null(columns_w_values_for_single_analyte)
))) { stop("You need to specify at least one column with values for analytes.")}
# Pre-process data
# Remove columns that are not included in input column lists
if (length(
which(!colnames(data) %in%
c(
columns_w_values_for_single_analyte,
columns_w_sample_ID_info
)
)
) > 0
) {
data <- data[,-which(!colnames(data) %in%
c(
columns_w_values_for_single_analyte,
columns_w_sample_ID_info
)
)]
}
# Check for duplicate analyte names
if( length(columns_w_values_for_single_analyte) > 0 ) {
if( any(duplicated(columns_w_values_for_single_analyte)) ) {
stop("There are duplicate analyte names in columns_w_values_for_single_analyte.")
}
}
# If no pivot required, skip pivoting
if( length(columns_w_values_for_single_analyte) >= 1 ) {
data_wide <- data
analyte_columns <- columns_w_values_for_single_analyte
data_wide <- unique(data_wide)
}
# Check to see if analyte columns are numeric and compatible with analysis
which_analyte_columns <- which(colnames(data_wide) %in% analyte_columns)
are_they_numeric <- list()
for( i in which_analyte_columns ) {
are_they_numeric <- c(are_they_numeric, is.numeric(data_wide[[i]]))
}
# Should selected analysis proceed?
if ( all(unlist(are_they_numeric)) ) {
if ( analysis %in% c("pca", "pca_dim", "pca_ord") ) {
# cat("Analytes are all numeric and compatible with the analysis selected.\n")
}
if ( analysis %in% c("mca", "mca_ord", "mca_dim") ) {
stop("Analytes are all numeric, but the analysis selected is for categorical variables. Please choose a different analysis method.\n")
}
}
if ( !all(unlist(are_they_numeric)) ) {
if (analysis %in% c("mca", "mca_ord", "mca_dim")) {
# cat("Analytes are all categorical and compatible with the analysis selected.\n")
}
if ( analysis %in% c("pca", "pca_dim", "pca_ord") ) {
stop("Analytes are all categorical, but the analysis selected is for numeric variables. Please choose a different analysis method.\n")
}
}
# Add sample_unique_ID_column if necessary, or just change column name of existing sample_unique_ID column
if( length(columns_w_sample_ID_info) > 1 ) {
sample_unique_IDs <- apply(
data_wide[,match(columns_w_sample_ID_info, colnames(data_wide))],
1, paste, collapse = "_"
)
if( any(duplicated(sample_unique_IDs)) ) {stop("columns_w_sample_ID_info specified do not lead to unique sample IDs")}
data_wide$sample_unique_ID <- sample_unique_IDs
} else {
colnames(data_wide)[colnames(data_wide) == columns_w_sample_ID_info] <- "sample_unique_ID"
if( any(duplicated(data_wide$sample_unique_ID)) ) {stop("columns_w_sample_ID_info specified do not lead to unique sample IDs")}
}
# Make sure "sample_unique_ID" is character
data_wide$sample_unique_ID <- as.character(data_wide$sample_unique_ID)
# Prepare the matrix
matrix <- as.data.frame(data_wide[,match(analyte_columns, colnames(data_wide))])
rownames(matrix) <- data_wide$sample_unique_ID
# Handle NAs
if( na_replacement[1] == "none") {
}
if( na_replacement[1] == "drop" ) {
message("Dropping any variables in your dataset that have NA as a value.\nVariables dropped:\n")
if (length(names(which(apply(is.na(matrix), 2, any)))) > 0) {
message(names(which(apply(is.na(matrix), 2, any))))
} else {
message("none")
}
cat("\n")
matrix <- matrix[,!apply(is.na(matrix), 2, any)]
}
if( na_replacement[1] %in% c("zero", "mean") ) {
if( any(is.na(matrix)) ) {
message(paste0("Replacing NAs in your data with ", na_replacement[1]), "\n")
for( column in 1:dim(matrix)[2]) {
if( any(is.na(matrix[,column])) ) {
if( na_replacement[1] == "mean" ) {
replacement <- mean(matrix[,column], na.rm = TRUE)
}
if( na_replacement[1] == "zero" ) {
replacement <- 0
}
if( !any(na_replacement %in% c("mean", "zero")) ) {
stop("Your data contains NAs. Please specify how to deal with them using na_replacement. \n")
}
matrix[,column][is.na(matrix[,column])] <- as.numeric(replacement)
} else {}
}
}
}
# Scale data, unless not requested
if ( is.null(scale_variance) ) {
if (analysis != "hclust") {scale_variance <- TRUE} else {scale_variance <- FALSE}
}
if( scale_variance == TRUE & !analysis %in% c("mca", "mca_ord", "mca_dim")) {
scaled_matrix <- scale(matrix)
if( any(is.na(scaled_matrix)) ) {
message("Some analytes have zero variance and will be assigned a value of zero in the scaled matrix.")
scaled_matrix[is.na(scaled_matrix)] <- 0
}
}
if( scale_variance == FALSE ) {
scaled_matrix <- matrix
}
# Generate distance matrix
if(  !analysis %in% c("mca", "mca_ord", "mca_dim") ) {
if (distance_method[1] == "gower") {
dist_matrix <- cluster::daisy(scaled_matrix, metric = "gower")
} else {
dist_matrix <- stats::dist(scaled_matrix, method = distance_method[1])
}
if( analysis == "dist") {
df <- as.data.frame(as.table(as.matrix(dist_matrix)))
names(df) <- c("sample_1", "sample_2", "distance")
df <- filter(df, distance != 0)
clustering <- df
clustering <- right_join(
data_wide[,match(
c(columns_w_sample_ID_info, "sample_unique_ID"),
colnames(data_wide))
], clustering, by = c("sample_unique_ID" = "sample_1"), suffix = c("sample_1", "sample_2")
)
clustering <- right_join(
data_wide[,match(
c(columns_w_sample_ID_info, "sample_unique_ID"),
colnames(data_wide))
], clustering, by = c("sample_unique_ID" = "sample_2"), suffix = c("_sample_1", "_sample_2")
)
colnames(clustering)[colnames(clustering) == "sample_unique_ID"] <- "sample_unique_ID_sample_1"
clustering <- select(clustering, sample_unique_ID_sample_1, sample_unique_ID_sample_2, distance, everything())
return(clustering)
# return(dist_matrix)
stop()
}
}
if( analysis %in% c("mca", "mca_ord", "mca_dim") ) { scaled_matrix <- matrix }
# Run the matrix analysis selected
## HCLUST, HCLUST_PHYLO ##
if( analysis %in% c("hclust", "hclust_phylo")) {
if (tree_method[1] == "linkage_dendrogram") {
## BClust approach to bootstrapped hclust
bclust <- Bclust(
scaled_matrix, method.d = distance_method[1],
method.c = agglomeration_method[1],
monitor = FALSE
)
phylo <- ape::as.phylo(bclust$hclust)
} else if (tree_method[1] == "neighbor_joining") {
phylo <- ape::nj(dist_matrix)
}
if( analysis == "hclust_phylo" ) {
return(phylo)
stop("Returning hclust_phylo.")
}
clustering <- ggtree::fortify(phylo)
clustering$sample_unique_ID <- clustering$label
clustering$bootstrap <- NA
## Add bootstrap values starting from the furthest node to the highest node
if (tree_method[1] == "linkage_dendrogram") {
bs_vals <- data.frame(
xval = clustering$x[clustering$isTip != TRUE],
bs_val = NA
)
for (i in 1:length(bclust$value)) { # i=1
bs_vals$bs_val[
order(bs_vals$xval, decreasing = TRUE)[i]
] <- bclust$values[i]
}
clustering$bootstrap[clustering$isTip != TRUE] <- bs_vals$bs_val
}
}
if (analysis == "hclust_cat") {
## "bootstrap" approach
temp <- as.data.frame(lapply(scaled_matrix, function(x) if(is.character(x)) factor(x) else x))
rownames(temp) <- rownames(scaled_matrix)
scaled_matrix <- temp
createHclustObject <- function(x)hclust(cluster::daisy(x, metric = distance_method[1]), method = agglomeration_method[1])
b <- bootstrap(scaled_matrix, fun = createHclustObject, n = 100L)
phylo <- ape::as.phylo(createHclustObject(scaled_matrix))
clustering <- ggtree::fortify(phylo)
clustering$sample_unique_ID <- clustering$label
clustering$bootstrap <- NA
## Add bootstrap values starting from the furthest node to the highest node
bs_vals <- data.frame( xval = clustering$x[clustering$isTip != TRUE], bs_val = NA )
for (i in 1:length(b)) { bs_vals$bs_val[order(bs_vals$xval, decreasing = TRUE)[i]] <- b[i] }
clustering$bootstrap[clustering$isTip != TRUE] <- bs_vals$bs_val
}
## Dimensionality reduction
## MDS
if( analysis == "mds" ) {
coords <- stats::cmdscale(dist_matrix)
colnames(coords) <- c("Dim_1", "Dim_2")
clustering <- as_tibble(coords)
clustering$sample_unique_ID <- rownames(coords)
}
## tSNE
if( analysis == "tsne" ) {
clustering <- Rtsne(scaled_matrix, theta = 0.0, perplexity = 2)
clustering <- as.data.frame(clustering$Y)
clustering$sample_unique_ID <- rownames(scaled_matrix)
colnames(clustering) <- c("Dim_1", "Dim_2", "sample_unique_ID")
clustering <- select(clustering, sample_unique_ID, Dim_1, Dim_2)
rownames(clustering) <- NULL
}
## umap
if( analysis == "umap" ) {
clustering <- as.data.frame(umap(scaled_matrix)$layout)
clustering$sample_unique_ID <- rownames(clustering)
colnames(clustering) <- c("Dim_1", "Dim_2", "sample_unique_ID")
clustering <- select(clustering, sample_unique_ID, Dim_1, Dim_2)
rownames(clustering) <- NULL
}
## MCA, MCA_ORD, MCA_DIM ##
if( analysis == "mca" ) {
message("Running Multiple Correspondence Analysis, extracting sample coordinates...\n")
coords <- FactoMineR::MCA(matrix, graph = FALSE)$ind$coord[,c(1:components_to_return)]
clustering <- as_tibble(coords)
clustering$sample_unique_ID <- rownames(coords)
colnames(clustering) <- c("Dim_1", "Dim_2", "sample_unique_ID")
message("Done!\n")
}
if( analysis == "mca_ord" ) {
message("Running Multiple Correspondence Analysis, extracting ordination plot...\n")
coords <- FactoMineR::MCA(matrix, graph = FALSE)$var$eta2[,c(1,components_to_return)]
clustering <- as_tibble(coords)
clustering$analyte <- rownames(coords)
colnames(clustering) <- c("Dim_1", "Dim_2", "analyte")
clustering <- select(clustering, analyte, Dim_1, Dim_2)
return(clustering)
stop("Returning ordination plot coordinates. \nDone!")
}
if( analysis == "mca_dim" ) {
message("Running Multiple Correspondence Analysis, extracting dimensional contributions...\n")
coords <- FactoMineR::MCA(matrix, graph = FALSE)$eig[,2]
clustering <- tibble::enframe(coords, name = NULL)
clustering$principal_component <- names(coords)
clustering$principal_component <- as.numeric(gsub("dim ", "", clustering$principal_component))
colnames(clustering)[colnames(clustering) == "value"] <- "percent_variance_explained"
clustering <- select(clustering, principal_component, percent_variance_explained)
return(clustering)
stop("Returning eigenvalues. \nDone!")
}
## PCA, PCA_ORD, PCA_DIM ##
if( analysis == "pca" ) {
coords <- FactoMineR::PCA(scaled_matrix, graph = FALSE, scale.unit = FALSE)$ind$coord[,c(1:components_to_return)]
clustering <- as_tibble(coords)
clustering$sample_unique_ID <- rownames(coords)
# colnames(clustering) <- c("Dim_1", "Dim_2", "sample_unique_ID")
}
if( analysis == "pca_ord" ) {
coords <- FactoMineR::PCA(scaled_matrix, graph = FALSE, scale.unit = FALSE)$var$coord[,c(1:components_to_return)]
clustering <- as_tibble(coords)
clustering$analyte <- rownames(coords)
clustering <- select(clustering, analyte, c(paste0("Dim.", seq(1,components_to_return,1))))
# colnames(clustering) <- c("analyte", "Dim_1", "Dim_2")
return(clustering)
stop("Returning ordination plot coordinates.")
}
if( analysis == "pca_dim" ) {
coords <- FactoMineR::PCA(scaled_matrix, graph = FALSE, scale.unit = FALSE)$eig[,2]
clustering <- tibble::enframe(coords, name = NULL)
clustering$principal_component <- names(coords)
clustering$principal_component <- as.numeric(gsub("comp ", "", clustering$principal_component))
colnames(clustering)[colnames(clustering) == "value"] <- "percent_variance_explained"
clustering <- select(clustering, principal_component, percent_variance_explained)
return(clustering)
stop("Returning eigenvalues.")
}
## Clustering
if(  !analysis %in% c("mca", "mca_ord", "mca_dim") ) {
if( any(is.na(scaled_matrix)) == TRUE ) {
stop("clustering cannot handle NA. Please choose an option for na_replacement.")
}
}
## DBSCAN
if( analysis == "dbscan" ) {
if ( length(parameters) > 0 ) {
cluster_k <- parameters[1]
cluster_threshold <- parameters[2]
}
if ( length(parameters) == 0 ) {
findClusterParameters(dist_matrix = dist_matrix, matrix = matrix, analysis = "dbscan")
}
message("Using", cluster_k, "as a value for k.\n")
message("Using", cluster_threshold, "as a value for threshold.\n")
clustering <- as_tibble(data.frame(
sample_unique_ID = colnames(as.matrix(dist_matrix)),
cluster = paste0("cluster_", fpc::dbscan(dist_matrix, eps = as.numeric(cluster_threshold), MinPts = as.numeric(cluster_k), scale = FALSE, method = "dist")[[1]])
))
clustering$cluster[clustering$cluster == "cluster_0"] <- NA
}
## k-means
if (analysis == "kmeans") {
if ( length(parameters) > 0 ) {
n_clusters <- parameters[1]
}
if ( length(parameters) == 0 ) {
findClusterParameters(dist_matrix = dist_matrix, matrix = matrix, analysis = "kmeans")
}
message("Using", n_clusters, "as a value for cluster_number.\n")
clustering <- as_tibble(data.frame(
sample_unique_ID = colnames(as.matrix(dist_matrix)),
cluster = stats::kmeans(x = matrix, centers = as.numeric(n_clusters), nstart = 25, iter.max = 1000)$cluster
))
}
## OPTICS
# out <- dbscan::optics(scaled_matrix, minPts = 5)
# out <- data.frame(
#     order = out$order,
#     reach_dist = out$reachdist,
#     name = rownames(scaled_matrix)
# )
# out$name <- factor(out$name, levels = rev(rownames(scaled_matrix)[out$order]))
# ggplot(out[2:19,]) +
#     geom_col(aes(x = name, y = reach_dist))
# Post processing and return.
if( !analysis %in% c("hclust_phylo")) {
## Add back annotations to the output
if( length(columns_w_sample_ID_info) == 1 ) {
} else {
clustering <-   right_join(
data_wide[,match(
c(columns_w_sample_ID_info, "sample_unique_ID"),
colnames(data_wide))
], clustering, by = "sample_unique_ID"
)
}
rownames_matrix <- tibble::enframe(rownames(scaled_matrix), name = NULL)
colnames(rownames_matrix)[1] <- "sample_unique_ID"
# if (analysis != "pca") { ## Don't do this for pca for some reason?? I don't understand why...
clustering <- full_join(
clustering,
as_tibble(cbind(rownames_matrix, as_tibble(matrix))),
by = "sample_unique_ID"
)
# }
# clustering
## Order the returned matrix so that the sample_unique_ID comes first
clustering <- select(clustering, sample_unique_ID, everything())
# Annotate internal nodes in tree output if all its descendants share a property
if( analysis == "hclust" ) {
for( node in dplyr::filter(clustering, isTip == FALSE)$node ) {
for (sample_property in colnames(clustering)[colnames(clustering) %in% columns_w_sample_ID_info] ) {
descends <- clustering[clustering$node %in% ips::descendants(phylo, node),]
if (length( unlist(unique(descends[,colnames(descends) == sample_property])) ) == 1 ) {
clustering[
which(clustering$node == node),
which(colnames(clustering) == sample_property)
] <- unlist(descends[,colnames(descends) == sample_property])[1]
}
}
}
}
# Return results
if( output_format[1] == "long" ) {
clustering <- pivot_longer(
clustering,
cols = c(which(colnames(clustering) == analyte_columns[1]): dim(clustering)[2]),
names_to = "analyte_name",
values_to = "value"
)
analyte_annotation_frame <- unique(select(ungroup(data), all_of(c(column_w_names_of_multiple_analytes, columns_w_additional_analyte_info))))
clustering <- left_join(clustering, analyte_annotation_frame, by = c("analyte_name" = column_w_names_of_multiple_analytes))
}
return( clustering )
}
}
runMatrixAnalyses(
data = alaska_lake_data_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(alaska_lake_data_wide)[3:15],
columns_w_sample_ID_info = c("lake", "park")
)
View(are_they_numeric)
View(are_they_numeric)
View(beer_components)
beer_components
beer_components_wide <- pivot_wider(select(beer_components, -analyte_class, -analyte_odor), names_from = "analyte", values_from = abundance)
beer_components_wide
runMatrixAnalyses(
data = beer_components_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(beer_components_wide)[3:147],
columns_w_sample_ID_info = c("ingredient", "replicate")
)
beer_components_wide_dist$same <- beer_components_wide_dist$ingredient_sample_1 == beer_components_wide_dist$ingredient_sample_2
beer_components_wide <- pivot_wider(select(beer_components, -analyte_class, -analyte_odor), names_from = "analyte", values_from = abundance)
beer_components_wide_dist <- runMatrixAnalyses(
data = beer_components_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(beer_components_wide)[3:147],
columns_w_sample_ID_info = c("ingredient", "replicate")
)
beer_components_wide_dist$same <- beer_components_wide_dist$ingredient_sample_1 == beer_components_wide_dist$ingredient_sample_2
beer_components_wide_dist
beer_components_wide_dist
beer_components_wide_dist %>%
ggplot(aes(x = same, y = distance)) + geom_point()
beer_components_wide <- pivot_wider(select(beer_components, -analyte_class, -analyte_odor), names_from = "analyte", values_from = abundance)
beer_components_wide_dist <- runMatrixAnalyses(
data = beer_components_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(beer_components_wide)[3:147],
columns_w_sample_ID_info = c("ingredient", "replicate")
)
head(beer_components_wide_dist)
beer_components_wide_dist$same <- beer_components_wide_dist$ingredient_sample_1 == beer_components_wide_dist$ingredient_sample_2
beer_components_wide_dist %>%
ggplot(aes(x = same, y = distance)) + geom_point()
beer_components_wide_dist %>%
ggplot(aes(x = same, y = distance)) + geom_jitter()
## t test
tTest(beer_components_wide_dist, distance~same)
## pivot beer_components wider
beer_components_wide <- pivot_wider(select(beer_components, -analyte_class, -analyte_odor), names_from = "analyte", values_from = abundance)
## compute distance matrix
beer_components_wide_dist <- runMatrixAnalyses(
data = beer_components_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(beer_components_wide)[3:147],
columns_w_sample_ID_info = c("ingredient", "replicate")
)
head(beer_components_wide_dist)
## create a new column based on whether a pair shares
beer_components_wide_dist$same <- beer_components_wide_dist$ingredient_sample_1 == beer_components_wide_dist$ingredient_sample_2
## t test
tTest(beer_components_wide_dist, distance~same)
## plot
beer_components_wide_dist %>%
ggplot(aes(x = same, y = distance)) + geom_jitter()
## pivot beer_components wider
beer_components_wide <- pivot_wider(select(beer_components, -analyte_class, -analyte_odor), names_from = "analyte", values_from = abundance)
## compute distance matrix
beer_components_wide_dist <- runMatrixAnalyses(
data = beer_components_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(beer_components_wide)[3:147],
columns_w_sample_ID_info = c("ingredient", "replicate")
)
head(beer_components_wide_dist)
## create a new column based on whether a pair shares
beer_components_wide_dist$same <- beer_components_wide_dist$ingredient_sample_1 == beer_components_wide_dist$ingredient_sample_2
## t test
tTest(beer_components_wide_dist, distance~same)
## plot
beer_components_wide_dist %>%
ggplot(aes(x = same, y = distance)) + geom_jitter()
## pivot beer_components wider
beer_components_wide <- pivot_wider(select(beer_components, -analyte_class, -analyte_odor), names_from = "analyte", values_from = abundance)
## compute distance matrix
beer_components_wide_dist <- runMatrixAnalyses(
data = beer_components_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(beer_components_wide)[3:147],
columns_w_sample_ID_info = c("ingredient", "replicate")
)
head(beer_components_wide_dist)
## create a new column based on whether a pair shares
beer_components_wide_dist$same <- beer_components_wide_dist$ingredient_sample_1 == beer_components_wide_dist$ingredient_sample_2
## t test
tTest(beer_components_wide_dist, distance~same)
## plot
beer_components_wide_dist %>%
ggplot(aes(x = same, y = distance)) + geom_jitter()
## pivot beer_components wider
beer_components_wide <- pivot_wider(select(beer_components, -analyte_class, -analyte_odor), names_from = "analyte", values_from = abundance)
## compute distance matrix
beer_components_wide_dist <- runMatrixAnalyses(
data = beer_components_wide,
analysis = c("dist"),
columns_w_values_for_single_analyte = colnames(beer_components_wide)[3:147],
columns_w_sample_ID_info = c("ingredient", "replicate")
)
head(beer_components_wide_dist)
## create a new column based on whether a pair shares
beer_components_wide_dist$same <- beer_components_wide_dist$ingredient_sample_1 == beer_components_wide_dist$ingredient_sample_2
## t test
tTest(beer_components_wide_dist, distance~same)
## plot
beer_components_wide_dist %>%
ggplot(aes(x = same, y = distance)) + geom_jitter()
